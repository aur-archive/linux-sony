Signed-off-by: Marco Chiappero <marco@absence.it>

--- a/drivers/acpi/video_detect.c
+++ b/drivers/acpi/video_detect.c
@@ -45,6 +45,24 @@ ACPI_MODULE_NAME("video");
 static long acpi_video_support;
 static bool acpi_video_caps_checked;
 
+static const struct dmi_system_id vendor_dmi_table[] = {
+	{
+		.ident = "Sony Vaio S1",
+		.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "VPCS1"),
+		},
+	},
+	{
+		.ident = "Sony Vaio TT",
+		.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Sony Corporation"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "VGN-TT"),
+		},
+	},
+	{ }
+};
+
 static acpi_status
 acpi_backlight_cap_match(acpi_handle handle, u32 level, void *context,
 			  void **retyurn_value)
@@ -163,6 +181,9 @@ long acpi_video_get_capabilities(acpi_ha
 		 *		ACPI_VIDEO_BACKLIGHT_DMI_VENDOR;
 		 *}
 		 */
+		if (dmi_check_system(vendor_dmi_table))
+			acpi_video_support |= ACPI_VIDEO_BACKLIGHT_DMI_VENDOR;
+
 	} else {
 		status = acpi_bus_get_device(graphics_handle, &tmp_dev);
 		if (ACPI_FAILURE(status)) {
 
--- a/drivers/platform/x86/sony-laptop.c
+++ b/drivers/platform/x86/sony-laptop.c
@@ -3,6 +3,8 @@
  *
  * Copyright (C) 2004-2005 Stelian Pop <stelian@popies.net>
  * Copyright (C) 2007-2009 Mattia Dongili <malattia@linux.it>
+ * Copyright (C) 2011 Marco Chiappero <marco@absence.it>
+ * Copyright (C) 2011 Javier Achirica <jachirica@gmail.com>
  *
  * Parts of this driver inspired from asus_acpi.c and ibm_acpi.c
  * which are copyrighted by their respective authors.
@@ -63,7 +65,7 @@
 #include <linux/slab.h>
 #include <acpi/acpi_drivers.h>
 #include <acpi/acpi_bus.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <linux/sonypi.h>
 #include <linux/sony-laptop.h>
 #include <linux/rfkill.h>
@@ -127,7 +129,7 @@ MODULE_PARM_DESC(minor,
 		 "default is -1 (automatic)");
 #endif
 
-static int kbd_backlight = 1;
+static int kbd_backlight = 0;
 module_param(kbd_backlight, int, 0444);
 MODULE_PARM_DESC(kbd_backlight,
 		 "set this to 0 to disable keyboard backlight, "
@@ -140,20 +142,13 @@ MODULE_PARM_DESC(kbd_backlight_timeout,
 		 "1 for 30 seconds, 2 for 60 seconds and 3 to disable timeout "
 		 "(default: 0)");
 
-static void sony_nc_kbd_backlight_resume(void);
+static int force_shock_notifications;	/* = 0 */
+module_param(force_shock_notifications, int, 0);
+MODULE_PARM_DESC(force_shock_notifications,
+		"set this to 1 to force the generation of shock protection "
+		"events, even though the notebook do not support head "
+		"unloading for the installed drive drive");
 
-enum sony_nc_rfkill {
-	SONY_WIFI,
-	SONY_BLUETOOTH,
-	SONY_WWAN,
-	SONY_WIMAX,
-	N_SONY_RFKILL,
-};
-
-static int sony_rfkill_handle;
-static struct rfkill *sony_rfkill_devices[N_SONY_RFKILL];
-static int sony_rfkill_address[N_SONY_RFKILL] = {0x300, 0x500, 0x700, 0x900};
-static void sony_nc_rfkill_update(void);
 
 /*********** Input Devices ***********/
 
@@ -253,7 +248,7 @@ static int sony_laptop_input_index[] = {
 	57,	/* 70 SONYPI_EVENT_VOLUME_DEC_PRESSED */
 	-1,	/* 71 SONYPI_EVENT_BRIGHTNESS_PRESSED */
 	58,	/* 72 SONYPI_EVENT_MEDIA_PRESSED */
-	59,	/* 72 SONYPI_EVENT_VENDOR_PRESSED */
+	59,	/* 73 SONYPI_EVENT_VENDOR_PRESSED */
 };
 
 static int sony_laptop_input_keycode_map[] = {
@@ -377,7 +372,8 @@ static void sony_laptop_report_input_eve
 
 	default:
 		if (event >= ARRAY_SIZE(sony_laptop_input_index)) {
-			dprintk("sony_laptop_report_input_event, event not known: %d\n", event);
+			dprintk("sony_laptop_report_input_event, "
+				"event not known: %d\n", event);
 			break;
 		}
 		if (sony_laptop_input_index[event] != -1) {
@@ -565,12 +561,12 @@ static int sony_pf_add(void)
 
 	return 0;
 
-      out_platform_alloced:
+out_platform_alloced:
 	platform_device_put(sony_pf_device);
 	sony_pf_device = NULL;
-      out_platform_registered:
+out_platform_registered:
 	platform_driver_unregister(&sony_pf_driver);
-      out:
+out:
 	atomic_dec(&sony_pf_users);
 	return ret;
 }
@@ -664,7 +660,8 @@ static struct sony_nc_value sony_nc_valu
 	SNC_HANDLE(brightness_default, snc_brightness_def_get,
 			snc_brightness_def_set, brightness_default_validate, 0),
 	SNC_HANDLE(fnkey, snc_fnkey_get, NULL, NULL, 0),
-	SNC_HANDLE(cdpower, snc_cdpower_get, snc_cdpower_set, boolean_validate, 0),
+	SNC_HANDLE(cdpower, snc_cdpower_get, snc_cdpower_set,
+			boolean_validate, 0),
 	SNC_HANDLE(audiopower, snc_audiopower_get, snc_audiopower_set,
 			boolean_validate, 0),
 	SNC_HANDLE(lanpower, snc_lanpower_get, snc_lanpower_set,
@@ -684,12 +681,13 @@ static struct sony_nc_value sony_nc_valu
 };
 
 static acpi_handle sony_nc_acpi_handle;
-static struct acpi_device *sony_nc_acpi_device = NULL;
+static struct acpi_device *sony_nc_acpi_device;
 
 /*
  * acpi_evaluate_object wrappers
  */
-static int acpi_callgetfunc(acpi_handle handle, char *name, int *result)
+static int acpi_callgetfunc(acpi_handle handle, char *name,
+				unsigned int *result)
 {
 	struct acpi_buffer output;
 	union acpi_object out_obj;
@@ -709,8 +707,8 @@ static int acpi_callgetfunc(acpi_handle 
 	return -1;
 }
 
-static int acpi_callsetfunc(acpi_handle handle, char *name, int value,
-			    int *result)
+static int acpi_callsetfunc(acpi_handle handle, char *name, u32 value,
+				unsigned int *result)
 {
 	struct acpi_object_list params;
 	union acpi_object in_obj;
@@ -730,7 +728,8 @@ static int acpi_callsetfunc(acpi_handle 
 	if (status == AE_OK) {
 		if (result != NULL) {
 			if (out_obj.type != ACPI_TYPE_INTEGER) {
-				pr_warn("acpi_evaluate_object bad return type\n");
+				pr_warn("acpi_evaluate_object bad "
+					"return type\n");
 				return -1;
 			}
 			*result = out_obj.integer.value;
@@ -743,6 +742,72 @@ static int acpi_callsetfunc(acpi_handle 
 	return -1;
 }
 
+static int acpi_callsetfunc_buffer(acpi_handle handle, u64 value,
+					u8 array[], unsigned int size)
+{
+	u8 buffer[sizeof(value)];
+	int length = -1;
+	struct acpi_object_list params;
+	union acpi_object in_obj;
+	union acpi_object *values;
+	struct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_status status;
+
+	if (!array || !size)
+		return length;
+
+	/* use a buffer type as parameter to overcome any 32 bits ACPI limit */
+	memcpy(buffer, &value, sizeof(buffer));
+
+	params.count = 1;
+	params.pointer = &in_obj;
+	in_obj.type = ACPI_TYPE_BUFFER;
+	in_obj.buffer.length = sizeof(buffer);
+	in_obj.buffer.pointer = buffer;
+
+	/* since SN06 is the only known method returning a buffer we
+	 * can hard code it, it is not necessary to have a parameter
+	 */
+	status = acpi_evaluate_object(sony_nc_acpi_handle, "SN06", &params,
+			&output);
+	values = (union acpi_object *) output.pointer;
+	if (ACPI_FAILURE(status) || !values) {
+		dprintk("acpi_evaluate_object failed\n");
+		goto error;
+	}
+
+	/* some buggy DSDTs return integer when the output does
+	   not execede the 4 bytes size
+	*/
+	if (values->type == ACPI_TYPE_BUFFER) {
+		if (values->buffer.length <= 0)
+			goto error;
+
+		length = size > values->buffer.length ?
+			values->buffer.length : size;
+
+		memcpy(array, values->buffer.pointer, length);
+	} else if (values->type == ACPI_TYPE_INTEGER) {
+		u32 result = values->integer.value;
+		if (size < 4)
+			goto error;
+
+		length = 0;
+		while (length != 4) {
+			array[length] = result & 0xff;
+			result >>= 8;
+			length++;
+		}
+	} else {
+		pr_err("Invalid return object 0x%.2x\n", values->type);
+		goto error;
+	}
+
+error:
+	kfree(output.pointer);
+	return length;
+}
+
 struct sony_nc_handles {
 	u16 cap[0x10];
 	struct device_attribute devattr;
@@ -767,8 +832,7 @@ static ssize_t sony_nc_handles_show(stru
 
 static int sony_nc_handles_setup(struct platform_device *pd)
 {
-	int i;
-	int result;
+	unsigned int i, result;
 
 	handles = kzalloc(sizeof(*handles), GFP_KERNEL);
 	if (!handles)
@@ -811,12 +875,12 @@ static int sony_nc_handles_cleanup(struc
 	return 0;
 }
 
-static int sony_find_snc_handle(int handle)
+static int sony_find_snc_handle(unsigned int handle)
 {
 	int i;
 
-	/* not initialized yet, return early */
-	if (!handles)
+	/* not initialized yet or invalid handle, return early */
+	if (!handles || !handle)
 		return -1;
 
 	for (i = 0; i < 0x10; i++) {
@@ -830,7 +894,9 @@ static int sony_find_snc_handle(int hand
 	return -1;
 }
 
-static int sony_call_snc_handle(int handle, int argument, int *result)
+/* call command method SN07, accepts a 32 bit integer, returns a integer */
+static int sony_call_snc_handle(unsigned int handle, unsigned int argument,
+				unsigned int *result)
 {
 	int ret = 0;
 	int offset = sony_find_snc_handle(handle);
@@ -838,6 +904,7 @@ static int sony_call_snc_handle(int hand
 	if (offset < 0)
 		return -1;
 
+	/* max 32 bit wide argument, for wider input use SN06 */
 	ret = acpi_callsetfunc(sony_nc_acpi_handle, "SN07", offset | argument,
 			result);
 	dprintk("called SN07 with 0x%.4x (result: 0x%.4x)\n", offset | argument,
@@ -845,6 +912,24 @@ static int sony_call_snc_handle(int hand
 	return ret;
 }
 
+/* call command method SN06, accepts a wide input buffer, returns a buffer */
+static int sony_call_snc_handle_buffer(unsigned int handle, u64 argument,
+					u8 result[], unsigned int size)
+{
+	int ret = 0;
+	int offset = sony_find_snc_handle(handle);
+
+	if (offset < 0)
+		return -1;
+
+	ret = acpi_callsetfunc_buffer(sony_nc_acpi_handle,
+			offset | argument, result, size);
+	dprintk("called SN06 with 0x%.4llx (%u bytes read)\n",
+			offset | argument, ret);
+
+	return ret;
+}
+
 /*
  * sony_nc_values input/output validate functions
  */
@@ -857,11 +942,11 @@ static int sony_call_snc_handle(int hand
 static int brightness_default_validate(const int direction, const int value)
 {
 	switch (direction) {
-		case SNC_VALIDATE_OUT:
-			return value - 1;
-		case SNC_VALIDATE_IN:
-			if (value >= 0 && value < SONY_MAX_BRIGHTNESS)
-				return value + 1;
+	case SNC_VALIDATE_OUT:
+		return value - 1;
+	case SNC_VALIDATE_IN:
+		if (value >= 0 && value < SONY_MAX_BRIGHTNESS)
+			return value + 1;
 	}
 	return -EINVAL;
 }
@@ -883,10 +968,11 @@ static int boolean_validate(const int di
 /*
  * Sysfs show/store common to all sony_nc_values
  */
-static ssize_t sony_nc_sysfs_show(struct device *dev, struct device_attribute *attr,
-			      char *buffer)
+static ssize_t sony_nc_sysfs_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buffer)
 {
-	int value;
+	unsigned int value;
 	struct sony_nc_value *item =
 	    container_of(attr, struct sony_nc_value, devattr);
 
@@ -906,7 +992,7 @@ static ssize_t sony_nc_sysfs_store(struc
 			       struct device_attribute *attr,
 			       const char *buffer, size_t count)
 {
-	int value;
+	unsigned long value;
 	struct sony_nc_value *item =
 	    container_of(attr, struct sony_nc_value, devattr);
 
@@ -916,7 +1002,8 @@ static ssize_t sony_nc_sysfs_store(struc
 	if (count > 31)
 		return -EINVAL;
 
-	value = simple_strtoul(buffer, NULL, 10);
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
 
 	if (item->validate)
 		value = item->validate(SNC_VALIDATE_IN, value);
@@ -924,76 +1011,14 @@ static ssize_t sony_nc_sysfs_store(struc
 	if (value < 0)
 		return value;
 
-	if (acpi_callsetfunc(sony_nc_acpi_handle, *item->acpiset, value, NULL) < 0)
+	if (acpi_callsetfunc(sony_nc_acpi_handle,
+				*item->acpiset, value, NULL) < 0)
 		return -EIO;
 	item->value = value;
 	item->valid = 1;
 	return count;
 }
 
-
-/*
- * Backlight device
- */
-struct sony_backlight_props {
-	struct backlight_device *dev;
-	int			handle;
-	u8			offset;
-	u8			maxlvl;
-};
-struct sony_backlight_props sony_bl_props;
-
-static int sony_backlight_update_status(struct backlight_device *bd)
-{
-	return acpi_callsetfunc(sony_nc_acpi_handle, "SBRT",
-				bd->props.brightness + 1, NULL);
-}
-
-static int sony_backlight_get_brightness(struct backlight_device *bd)
-{
-	int value;
-
-	if (acpi_callgetfunc(sony_nc_acpi_handle, "GBRT", &value))
-		return 0;
-	/* brightness levels are 1-based, while backlight ones are 0-based */
-	return value - 1;
-}
-
-static int sony_nc_get_brightness_ng(struct backlight_device *bd)
-{
-	int result;
-	struct sony_backlight_props *sdev =
-		(struct sony_backlight_props *)bl_get_data(bd);
-
-	sony_call_snc_handle(sdev->handle, 0x0200, &result);
-
-	return (result & 0xff) - sdev->offset;
-}
-
-static int sony_nc_update_status_ng(struct backlight_device *bd)
-{
-	int value, result;
-	struct sony_backlight_props *sdev =
-		(struct sony_backlight_props *)bl_get_data(bd);
-
-	value = bd->props.brightness + sdev->offset;
-	if (sony_call_snc_handle(sdev->handle, 0x0100 | (value << 16), &result))
-		return -EIO;
-
-	return value;
-}
-
-static const struct backlight_ops sony_backlight_ops = {
-	.options = BL_CORE_SUSPENDRESUME,
-	.update_status = sony_backlight_update_status,
-	.get_brightness = sony_backlight_get_brightness,
-};
-static const struct backlight_ops sony_backlight_ng_ops = {
-	.options = BL_CORE_SUSPENDRESUME,
-	.update_status = sony_nc_update_status_ng,
-	.get_brightness = sony_nc_get_brightness_ng,
-};
-
 /*
  * New SNC-only Vaios event mapping to driver known keys
  */
@@ -1003,10 +1028,6 @@ struct sony_nc_event {
 };
 
 static struct sony_nc_event sony_100_events[] = {
-	{ 0x90, SONYPI_EVENT_PKEY_P1 },
-	{ 0x10, SONYPI_EVENT_ANYBUTTON_RELEASED },
-	{ 0x91, SONYPI_EVENT_PKEY_P2 },
-	{ 0x11, SONYPI_EVENT_ANYBUTTON_RELEASED },
 	{ 0x81, SONYPI_EVENT_FNKEY_F1 },
 	{ 0x01, SONYPI_EVENT_FNKEY_RELEASED },
 	{ 0x82, SONYPI_EVENT_FNKEY_F2 },
@@ -1021,12 +1042,20 @@ static struct sony_nc_event sony_100_eve
 	{ 0x06, SONYPI_EVENT_FNKEY_RELEASED },
 	{ 0x87, SONYPI_EVENT_FNKEY_F7 },
 	{ 0x07, SONYPI_EVENT_FNKEY_RELEASED },
+	{ 0x88, SONYPI_EVENT_FNKEY_F8 },
+	{ 0x08, SONYPI_EVENT_FNKEY_RELEASED },
 	{ 0x89, SONYPI_EVENT_FNKEY_F9 },
 	{ 0x09, SONYPI_EVENT_FNKEY_RELEASED },
 	{ 0x8A, SONYPI_EVENT_FNKEY_F10 },
 	{ 0x0A, SONYPI_EVENT_FNKEY_RELEASED },
+	{ 0x8B, SONYPI_EVENT_FNKEY_F11 },
+	{ 0x0B, SONYPI_EVENT_FNKEY_RELEASED },
 	{ 0x8C, SONYPI_EVENT_FNKEY_F12 },
 	{ 0x0C, SONYPI_EVENT_FNKEY_RELEASED },
+	{ 0x90, SONYPI_EVENT_PKEY_P1 },
+	{ 0x10, SONYPI_EVENT_ANYBUTTON_RELEASED },
+	{ 0x91, SONYPI_EVENT_PKEY_P2 },
+	{ 0x11, SONYPI_EVENT_ANYBUTTON_RELEASED },
 	{ 0x9d, SONYPI_EVENT_ZOOM_PRESSED },
 	{ 0x1d, SONYPI_EVENT_ANYBUTTON_RELEASED },
 	{ 0x9f, SONYPI_EVENT_CD_EJECT_PRESSED },
@@ -1061,158 +1090,159 @@ static struct sony_nc_event sony_127_eve
 };
 
 /*
- * ACPI callbacks
+ * ACPI device
  */
-static void sony_nc_notify(struct acpi_device *device, u32 event)
+static int sony_nc_function_setup(unsigned int handle)
 {
-	u32 ev = event;
-
-	if (ev >= 0x90) {
-		/* New-style event */
-		int result;
-		int key_handle = 0;
-		ev -= 0x90;
-
-		if (sony_find_snc_handle(0x100) == ev)
-			key_handle = 0x100;
-		if (sony_find_snc_handle(0x127) == ev)
-			key_handle = 0x127;
-
-		if (key_handle) {
-			struct sony_nc_event *key_event;
-
-			if (sony_call_snc_handle(key_handle, 0x200, &result)) {
-				dprintk("sony_nc_notify, unable to decode"
-					" event 0x%.2x 0x%.2x\n", key_handle,
-					ev);
-				/* restore the original event */
-				ev = event;
-			} else {
-				ev = result & 0xFF;
+	unsigned int result;
 
-				if (key_handle == 0x100)
-					key_event = sony_100_events;
-				else
-					key_event = sony_127_events;
-
-				for (; key_event->data; key_event++) {
-					if (key_event->data == ev) {
-						ev = key_event->event;
-						break;
-					}
-				}
-
-				if (!key_event->data)
-					pr_info("Unknown event: 0x%x 0x%x\n",
-						key_handle, ev);
-				else
-					sony_laptop_report_input_event(ev);
-			}
-		} else if (sony_find_snc_handle(sony_rfkill_handle) == ev) {
-			sony_nc_rfkill_update();
-			return;
-		}
-	} else
-		sony_laptop_report_input_event(ev);
+	if (handle == 0x0102)
+		sony_call_snc_handle(0x0102, 0x100, &result);
+	else
+		sony_call_snc_handle(handle, 0, &result);
 
-	dprintk("sony_nc_notify, event: 0x%.2x\n", ev);
-	acpi_bus_generate_proc_event(sony_nc_acpi_device, 1, ev);
+	return 0;
 }
 
-static acpi_status sony_walk_callback(acpi_handle handle, u32 level,
-				      void *context, void **return_value)
+static int sony_nc_hotkeys_decode(unsigned int handle)
 {
-	struct acpi_device_info *info;
+	int ret = -EINVAL;
+	unsigned int result = 0;
+	struct sony_nc_event *key_event;
+
+	if (sony_call_snc_handle(handle, 0x200, &result)) {
+		dprintk("sony_nc_hotkeys_decode,"
+				" unable to retrieve the hotkey\n");
+	} else {
+		result &= 0xff;
 
-	if (ACPI_SUCCESS(acpi_get_object_info(handle, &info))) {
-		pr_warn("method: name: %4.4s, args %X\n",
-			(char *)&info->name, info->param_count);
+		if (handle == 0x100)
+			key_event = sony_100_events;
+		else
+			key_event = sony_127_events;
 
-		kfree(info);
+		for (; key_event->data; key_event++) {
+			if (key_event->data == result) {
+				ret = key_event->event;
+				break;
+			}
+		}
+
+		if (!key_event->data)
+			pr_info("Unknown hotkey 0x%.2x (handle 0x%.2x)\n",
+							result, handle);
+		else
+			dprintk("sony_nc_hotkeys_decode, hotkey 0x%.2x decoded "
+					"to event 0x%.2x\n", result, ret);
 	}
 
-	return AE_OK;
+	return ret;
 }
 
-/*
- * ACPI device
- */
-static int sony_nc_function_setup(struct acpi_device *device)
-{
-	int result;
-
-	/* Enable all events */
-	acpi_callsetfunc(sony_nc_acpi_handle, "SN02", 0xffff, &result);
-
-	/* Setup hotkeys */
-	sony_call_snc_handle(0x0100, 0, &result);
-	sony_call_snc_handle(0x0101, 0, &result);
-	sony_call_snc_handle(0x0102, 0x100, &result);
-	sony_call_snc_handle(0x0127, 0, &result);
-
-	return 0;
-}
+enum sony_nc_rfkill {
+	SONY_WIFI,
+	SONY_BLUETOOTH,
+	SONY_WWAN,
+	SONY_WIMAX,
+	N_SONY_RFKILL,
+};
+struct sony_rfkill_data {
+	struct rfkill *devices[N_SONY_RFKILL];
+	const unsigned int address[N_SONY_RFKILL];
+	unsigned int handle;
+};
+static struct sony_rfkill_data sony_rfkill = {
+	{NULL}, {0x300, 0x500, 0x700, 0x900}, 0};
 
-static int sony_nc_resume(struct acpi_device *device)
+static int sony_nc_rfkill_update_wwan(void)
 {
-	struct sony_nc_value *item;
-	acpi_handle handle;
+	unsigned int result, cmd;
+	bool battery;
+	bool swblock;
 
-	for (item = sony_nc_values; item->name; item++) {
-		int ret;
+	if (sony_call_snc_handle(sony_rfkill.handle, 0x0200, &result))
+		return -EIO;
+	battery = !!(result & 0x2);
 
-		if (!item->valid)
-			continue;
-		ret = acpi_callsetfunc(sony_nc_acpi_handle, *item->acpiset,
-				       item->value, NULL);
-		if (ret < 0) {
-			pr_err("%s: %d\n", __func__, ret);
-			break;
-		}
-	}
+	/* retrieve the device block state */
+	if (sony_call_snc_handle(sony_rfkill.handle,
+				sony_rfkill.address[SONY_WWAN], &result))
+		return -EIO;
+	swblock = !(result & 0x02);
 
-	if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "ECON",
-					 &handle))) {
-		if (acpi_callsetfunc(sony_nc_acpi_handle, "ECON", 1, NULL))
-			dprintk("ECON Method failed\n");
+	if (battery && !swblock) {
+		/* set the power state according with swblock */
+		cmd = 0xff0000;
+	} else if (!battery && !swblock) {
+		swblock = true;
+		cmd = 0x20000;
+	} else {
+		return 0;
 	}
 
-	if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "SN00",
-					 &handle))) {
-		dprintk("Doing SNC setup\n");
-		sony_nc_function_setup(device);
-	}
+	cmd |= sony_rfkill.address[SONY_WWAN] + 0x100;
 
-	/* re-read rfkill state */
-	sony_nc_rfkill_update();
+	/* set the power state */
+	sony_call_snc_handle(sony_rfkill.handle, cmd, &result);
 
-	/* restore kbd backlight states */
-	sony_nc_kbd_backlight_resume();
+	/* update the rfkill sw state */
+	rfkill_set_sw_state(sony_rfkill.devices[SONY_WWAN], swblock);
 
 	return 0;
 }
 
+static int sony_nc_get_rfkill_hwblock(void)
+{
+	unsigned int result;
+
+	if (sony_call_snc_handle(sony_rfkill.handle, 0x200, &result))
+		return -1;
+
+	return result & 0x1;
+}
+
 static void sony_nc_rfkill_cleanup(void)
 {
 	int i;
 
 	for (i = 0; i < N_SONY_RFKILL; i++) {
-		if (sony_rfkill_devices[i]) {
-			rfkill_unregister(sony_rfkill_devices[i]);
-			rfkill_destroy(sony_rfkill_devices[i]);
+		if (sony_rfkill.devices[i]) {
+			rfkill_unregister(sony_rfkill.devices[i]);
+			rfkill_destroy(sony_rfkill.devices[i]);
 		}
 	}
 }
 
 static int sony_nc_rfkill_set(void *data, bool blocked)
 {
-	int result;
-	int argument = sony_rfkill_address[(long) data] + 0x100;
+	unsigned int result, argument = sony_rfkill.address[(long) data];
+
+	/* wwan state change not allowed when the battery is not present */
+	sony_call_snc_handle(sony_rfkill.handle, 0x0200, &result);
+	if (((long) data == SONY_WWAN) && !(result & 0x2)) {
+		if (!blocked) {
+			/* notify user space: the battery must be present */
+			acpi_bus_generate_proc_event(sony_nc_acpi_device,
+				       2, 2);
+			acpi_bus_generate_netlink_event(
+					sony_nc_acpi_device->pnp.device_class,
+					dev_name(&sony_nc_acpi_device->dev),
+					2, 2);
+		}
+
+		return -1;
+	}
 
+	/* do not force an already set state */
+	sony_call_snc_handle(sony_rfkill.handle, argument, &result);
+	if ((result & 0x1) == !blocked)
+		return 0;
+
+	argument += 0x100;
 	if (!blocked)
 		argument |= 0xff0000;
 
-	return sony_call_snc_handle(sony_rfkill_handle, argument, &result);
+	return sony_call_snc_handle(sony_rfkill.handle, argument, &result);
 }
 
 static const struct rfkill_ops sony_rfkill_ops = {
@@ -1226,8 +1256,8 @@ static int sony_nc_setup_rfkill(struct a
 	struct rfkill *rfk;
 	enum rfkill_type type;
 	const char *name;
-	int result;
-	bool hwblock;
+	unsigned int result;
+	bool hwblock, swblock, wwblock;
 
 	switch (nc_type) {
 	case SONY_WIFI:
@@ -1255,8 +1285,20 @@ static int sony_nc_setup_rfkill(struct a
 	if (!rfk)
 		return -ENOMEM;
 
-	sony_call_snc_handle(sony_rfkill_handle, 0x200, &result);
+	sony_call_snc_handle(sony_rfkill.handle, 0x200, &result);
 	hwblock = !(result & 0x1);
+	wwblock = !(result & 0x2);
+
+	result = 0;
+	sony_call_snc_handle(sony_rfkill.handle, sony_rfkill.address[nc_type],
+				&result);
+	swblock = !(result & 0x2);
+
+	/* hard block the WWAN module if no battery is present */
+	if ((nc_type == SONY_WWAN) && wwblock)
+		swblock = true;
+
+	rfkill_init_sw_state(rfk, swblock);
 	rfkill_set_hw_state(rfk, hwblock);
 
 	err = rfkill_register(rfk);
@@ -1264,412 +1306,3030 @@ static int sony_nc_setup_rfkill(struct a
 		rfkill_destroy(rfk);
 		return err;
 	}
-	sony_rfkill_devices[nc_type] = rfk;
+	sony_rfkill.devices[nc_type] = rfk;
 	return err;
 }
 
 static void sony_nc_rfkill_update(void)
 {
 	enum sony_nc_rfkill i;
-	int result;
-	bool hwblock;
+	unsigned int result;
+	bool hwblock, swblock, wwblock;
 
-	sony_call_snc_handle(sony_rfkill_handle, 0x200, &result);
+	sony_call_snc_handle(sony_rfkill.handle, 0x200, &result);
 	hwblock = !(result & 0x1);
+	wwblock = !(result & 0x2);
 
 	for (i = 0; i < N_SONY_RFKILL; i++) {
-		int argument = sony_rfkill_address[i];
+		unsigned int argument = sony_rfkill.address[i];
 
-		if (!sony_rfkill_devices[i])
+		if (!sony_rfkill.devices[i])
 			continue;
 
-		if (hwblock) {
-			if (rfkill_set_hw_state(sony_rfkill_devices[i], true)) {
-				/* we already know we're blocked */
-			}
-			continue;
-		}
+		sony_call_snc_handle(sony_rfkill.handle, argument, &result);
+		/* block wwan when no battery is present */
+		if ((i == SONY_WWAN) && wwblock)
+			swblock = true;
+		else
+			swblock = !(result & 0x2);
 
-		sony_call_snc_handle(sony_rfkill_handle, argument, &result);
-		rfkill_set_states(sony_rfkill_devices[i],
-				  !(result & 0xf), false);
+		rfkill_set_states(sony_rfkill.devices[i],
+				  swblock, hwblock);
 	}
 }
 
-static void sony_nc_rfkill_setup(struct acpi_device *device)
+static int sony_nc_rfkill_setup(struct acpi_device *device, unsigned int handle)
 {
-	int offset;
-	u8 dev_code, i;
-	acpi_status status;
-	struct acpi_object_list params;
-	union acpi_object in_obj;
-	union acpi_object *device_enum;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+#define	RFKILL_BUFF_SIZE 8
+	u8 dev_code, i, buff[RFKILL_BUFF_SIZE] = { 0 };
 
-	offset = sony_find_snc_handle(0x124);
-	if (offset == -1) {
-		offset = sony_find_snc_handle(0x135);
-		if (offset == -1)
-			return;
-		else
-			sony_rfkill_handle = 0x135;
-	} else
-		sony_rfkill_handle = 0x124;
-	dprintk("Found rkfill handle: 0x%.4x\n", sony_rfkill_handle);
+	sony_rfkill.handle = handle;
 
 	/* need to read the whole buffer returned by the acpi call to SN06
 	 * here otherwise we may miss some features
 	 */
-	params.count = 1;
-	params.pointer = &in_obj;
-	in_obj.type = ACPI_TYPE_INTEGER;
-	in_obj.integer.value = offset;
-	status = acpi_evaluate_object(sony_nc_acpi_handle, "SN06", &params,
-			&buffer);
-	if (ACPI_FAILURE(status)) {
-		dprintk("Radio device enumeration failed\n");
-		return;
-	}
-
-	device_enum = (union acpi_object *) buffer.pointer;
-	if (!device_enum) {
-		pr_err("No SN06 return object\n");
-		goto out_no_enum;
-	}
-	if (device_enum->type != ACPI_TYPE_BUFFER) {
-		pr_err("Invalid SN06 return object 0x%.2x\n",
-		       device_enum->type);
-		goto out_no_enum;
-	}
+	if (sony_call_snc_handle_buffer(sony_rfkill.handle, 0x000,
+					buff, RFKILL_BUFF_SIZE) < 0)
+		return -EIO;
 
 	/* the buffer is filled with magic numbers describing the devices
 	 * available, 0xff terminates the enumeration
 	 */
-	for (i = 0; i < device_enum->buffer.length; i++) {
+	for (i = 0; i < RFKILL_BUFF_SIZE; i++) {
 
-		dev_code = *(device_enum->buffer.pointer + i);
+		dev_code = buff[i];
 		if (dev_code == 0xff)
 			break;
 
+		/*
+		   known codes:
+
+		   0x00	WLAN
+		   0x10 BLUETOOTH
+		   0x20 WWAN GPRS-EDGE
+		   0x21 WWAN HSDPA
+		   0x22 WWAN EV-DO
+		   0x23 WWAN GPS
+		   0x25	Gobi WWAN no GPS
+		   0x26 Gobi WWAN + GPS
+		   0x28	Gobi WWAN no GPS
+		   0x29 Gobi WWAN + GPS
+		   0x50	Gobi WWAN no GPS
+		   0x51 Gobi WWAN + GPS
+		   0x30	WIMAX
+		   0x70 no SIM card slot
+		   0x71 SIM card slot
+		*/
 		dprintk("Radio devices, looking at 0x%.2x\n", dev_code);
 
-		if (dev_code == 0 && !sony_rfkill_devices[SONY_WIFI])
+		if (dev_code == 0 && !sony_rfkill.devices[SONY_WIFI])
 			sony_nc_setup_rfkill(device, SONY_WIFI);
 
-		if (dev_code == 0x10 && !sony_rfkill_devices[SONY_BLUETOOTH])
+		if (dev_code == 0x10 && !sony_rfkill.devices[SONY_BLUETOOTH])
 			sony_nc_setup_rfkill(device, SONY_BLUETOOTH);
 
-		if ((0xf0 & dev_code) == 0x20 &&
-				!sony_rfkill_devices[SONY_WWAN])
+		if (((0xf0 & dev_code) == 0x20 || (0xf0 & dev_code) == 0x50) &&
+				!sony_rfkill.devices[SONY_WWAN])
 			sony_nc_setup_rfkill(device, SONY_WWAN);
 
-		if (dev_code == 0x30 && !sony_rfkill_devices[SONY_WIMAX])
-			sony_nc_setup_rfkill(device, SONY_WIMAX);
+		if (dev_code == 0x30 && !sony_rfkill.devices[SONY_WIMAX])
+			sony_nc_setup_rfkill(device, SONY_WIMAX);
+	}
+
+	return 0;
+}
+
+/*	ALS controlled backlight feature	*/
+/* generic ALS data and interface */
+#define ALS_TABLE_SIZE	25
+
+struct als_device_ops {
+	int (*init)(const u8 defaults[]);
+	int (*exit)(void);
+	int (*event_handler)(void);
+	int (*set_power)(unsigned int);
+	int (*get_power)(unsigned int *);
+	int (*get_lux)(unsigned int *, unsigned int *);
+	int (*get_kelvin)(unsigned int *);
+};
+
+static struct  sony_als_device {
+	unsigned int handle;
+
+	unsigned int power;
+	unsigned int managed;
+
+	unsigned int levels_num;
+	u8 *levels;
+	unsigned int defaults_num;
+	u8 *defaults;
+	u8 parameters[ALS_TABLE_SIZE];
+
+	/* common device operations */
+	const struct als_device_ops *ops;
+
+	/* basic ALS sys interface */
+	unsigned int attrs_num;
+	struct device_attribute attrs[7];
+} *sony_als;
+
+/*
+	model specific ALS data and controls
+	TAOS TSL256x device data
+*/
+#define LUX_SHIFT_BITS		16	/* for non-floating point math */
+/* scale 100000 multiplied fractional coefficients rounding the values */
+#define SCALE(u)	((((((u64) u) << LUX_SHIFT_BITS) / 10000) + 5) / 10)
+
+#define TSL256X_REG_CTRL	0x00
+#define TSL256X_REG_TIMING	0x01
+#define TSL256X_REG_TLOW	0x02
+#define TSL256X_REG_THIGH	0x04
+#define TSL256X_REG_INT		0x06
+#define TSL256X_REG_ID		0x0a
+#define TSL256X_REG_DATA0	0x0c
+#define TSL256X_REG_DATA1	0x0e
+
+#define TSL256X_POWER_ON	0x03
+#define TSL256X_POWER_OFF	0x00
+
+#define TSL256X_POWER_MASK	0x03
+#define TSL256X_INT_MASK	0x10
+
+struct tsl256x_coeff {
+	u32 ratio;
+	u32 ch0;
+	u32 ch1;
+	u32 ka;
+	s32 kb;
+};
+
+struct tsl256x_data {
+	unsigned int gaintime;
+	unsigned int periods;
+	u8 *defaults;
+	struct tsl256x_coeff const *coeff_table;
+};
+static struct tsl256x_data *tsl256x_handle;
+
+static const struct tsl256x_coeff tsl256x_coeff_fn[] = {
+	{
+		.ratio	= SCALE(12500),	/* 0.125 * 2^LUX_SHIFT_BITS  */
+		.ch0	= SCALE(3040),	/* 0.0304 * 2^LUX_SHIFT_BITS */
+		.ch1	= SCALE(2720),	/* 0.0272 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(313550000),
+		.kb	= -10651,
+	}, {
+		.ratio	= SCALE(25000),	/* 0.250 * 2^LUX_SHIFT_BITS  */
+		.ch0	= SCALE(3250),	/* 0.0325 * 2^LUX_SHIFT_BITS */
+		.ch1	= SCALE(4400),	/* 0.0440 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(203390000),
+		.kb	= -2341,
+	}, {
+		.ratio	= SCALE(37500),	/* 0.375 * 2^LUX_SHIFT_BITS  */
+		.ch0	= SCALE(3510),	/* 0.0351 * 2^LUX_SHIFT_BITS */
+		.ch1	= SCALE(5440),	/* 0.0544 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(152180000),
+		.kb	= 157,
+	}, {
+		.ratio	= SCALE(50000),	/* 0.50 * 2^LUX_SHIFT_BITS   */
+		.ch0	= SCALE(3810),	/* 0.0381 * 2^LUX_SHIFT_BITS */
+		.ch1	= SCALE(6240),	/* 0.0624 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(163580000),
+		.kb	= -145,
+	}, {
+		.ratio	= SCALE(61000),	/* 0.61 * 2^LUX_SHIFT_BITS   */
+		.ch0	= SCALE(2240),	/* 0.0224 * 2^LUX_SHIFT_BITS */
+		.ch1	= SCALE(3100),	/* 0.0310 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(180800000),
+		.kb	= -495,
+	}, {
+		.ratio	= SCALE(80000),	/* 0.80 * 2^LUX_SHIFT_BITS   */
+		.ch0	= SCALE(1280),	/* 0.0128 * 2^LUX_SHIFT_BITS */
+		.ch1	= SCALE(1530),	/* 0.0153 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(197340000),
+		.kb	= -765
+	}, {
+		.ratio	= SCALE(130000),/* 1.3 * 2^LUX_SHIFT_BITS     */
+		.ch0	= SCALE(146),	/* 0.00146 * 2^LUX_SHIFT_BITS */
+		.ch1	= SCALE(112),	/* 0.00112 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(182900000),
+		.kb	= -608,
+	}, {
+		.ratio	= UINT_MAX,	/* for higher ratios */
+		.ch0	= 0,
+		.ch1	= 0,
+		.ka	= 0,
+		.kb	= 830,
+	}
+};
+
+static const struct tsl256x_coeff tsl256x_coeff_cs[] = {
+	{
+		.ratio  = SCALE(13000),	/* 0.130 * 2^LUX_SHIFT_BITS  */
+		.ch0    = SCALE(3150),	/* 0.0315 * 2^LUX_SHIFT_BITS */
+		.ch1    = SCALE(2620),	/* 0.0262 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(300370000),
+		.kb	= -9587,
+	}, {
+		.ratio  = SCALE(26000),	/* 0.260 * 2^LUX_SHIFT_BITS  */
+		.ch0    = SCALE(3370),	/* 0.0337 * 2^LUX_SHIFT_BITS */
+		.ch1    = SCALE(4300),	/* 0.0430 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(194270000),
+		.kb	= -1824,
+	}, {
+		.ratio  = SCALE(39000),	/* 0.390 * 2^LUX_SHIFT_BITS  */
+		.ch0    = SCALE(3630),	/* 0.0363 * 2^LUX_SHIFT_BITS */
+		.ch1    = SCALE(5290),	/* 0.0529 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(152520000),
+		.kb	= 145,
+	}, {
+		.ratio  = SCALE(52000),	/* 0.520 * 2^LUX_SHIFT_BITS  */
+		.ch0    = SCALE(3920),	/* 0.0392 * 2^LUX_SHIFT_BITS */
+		.ch1    = SCALE(6050),	/* 0.0605 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(165960000),
+		.kb	= -200,
+	}, {
+		.ratio  = SCALE(65000),	/* 0.650 * 2^LUX_SHIFT_BITS  */
+		.ch0    = SCALE(2290),	/* 0.0229 * 2^LUX_SHIFT_BITS */
+		.ch1    = SCALE(2910),	/* 0.0291 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(184800000),
+		.kb	= -566,
+	}, {
+		.ratio  = SCALE(80000),	/* 0.800 * 2^LUX_SHIFT_BITS  */
+		.ch0    = SCALE(1570),	/* 0.0157 * 2^LUX_SHIFT_BITS */
+		.ch1    = SCALE(1800),	/* 0.0180 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(199220000),
+		.kb	= -791,
+	}, {
+		.ratio  = SCALE(130000),/* 0.130 * 2^LUX_SHIFT_BITS  */
+		.ch0    = SCALE(338),	/* 0.00338 * 2^LUX_SHIFT_BITS */
+		.ch1    = SCALE(260),	/* 0.00260 * 2^LUX_SHIFT_BITS */
+		.ka	= SCALE(182900000),
+		.kb	= -608,
+	}, {
+		.ratio  = UINT_MAX,	/* for higher ratios */
+		.ch0    = 0,
+		.ch1    = 0,
+		.ka	= 0,
+		.kb	= 830,
+	}
+};
+
+/*	TAOS helper & control functions		*/
+static inline int tsl256x_exec_writebyte(unsigned int reg,
+						unsigned int const *value)
+{
+	unsigned int result;
+
+	return (sony_call_snc_handle(sony_als->handle, (*value << 0x18) |
+		(reg << 0x10) | 0x800500, &result) || !(result & 0x01))
+		? -EIO : 0;
+}
+
+static inline int tsl256x_exec_writeword(unsigned int reg,
+						unsigned int const *value)
+{
+	u8 result[1];
+	u64 arg = *value;
+
+	/* using sony_call_snc_handle_buffer due to possible input overflows */
+	return ((sony_call_snc_handle_buffer(sony_als->handle, (arg << 0x18) |
+				(reg << 0x10) | 0xA00700, result, 1) < 0) ||
+				!(result[0] & 0x01)) ? -EIO : 0;
+}
+
+static inline int tsl256x_exec_readbyte(unsigned int reg, unsigned int *result)
+{
+	if (sony_call_snc_handle(sony_als->handle, (reg << 0x10)
+		| 0x800400, result) || !(*result & 0x01))
+		return -EIO;
+	*result = (*result >> 0x08) & 0xFF;
+
+	return 0;
+}
+
+static inline int tsl256x_exec_readword(unsigned int reg, unsigned int *result)
+{
+	if (sony_call_snc_handle(sony_als->handle, (reg << 0x10)
+		| 0xA00600, result) || !(*result & 0x01))
+		return -EIO;
+	*result = (*result >> 0x08) & 0xFFFF;
+
+	return 0;
+}
+
+static int tsl256x_interrupt_ctrls(unsigned int *interrupt,
+					unsigned int *periods)
+{
+	unsigned int value, result;
+
+	/* if no interrupt parameter, retrieve interrupt status */
+	if (!interrupt) {
+		if (tsl256x_exec_readbyte(TSL256X_REG_INT, &result))
+			return -EIO;
+
+		value = (result & TSL256X_INT_MASK);
+	} else {
+		value = *interrupt << 0x04;
+	}
+
+	/* if no periods provided use the last one set */
+	value |= (periods ? *periods : tsl256x_handle->periods);
+
+	if (tsl256x_exec_writebyte(TSL256X_REG_INT, &value))
+		return -EIO;
+
+	if (periods)
+		tsl256x_handle->periods = *periods;
+
+	return 0;
+}
+
+static int tsl256x_setup(void)
+{
+	unsigned int interr = 1, zero = 0;
+
+	/*
+	 *   reset the threshold settings to trigger an event as soon
+	 *   as the event goes on, forcing a backlight adaptation to
+	 *   the current lighting conditions
+	 */
+	tsl256x_exec_writeword(TSL256X_REG_TLOW, &zero);
+	tsl256x_exec_writeword(TSL256X_REG_THIGH, &zero);
+
+	/* set gain and time */
+	if (tsl256x_exec_writebyte(TSL256X_REG_TIMING,
+				&tsl256x_handle->gaintime))
+		return -EIO;
+
+	/* restore persistence value and enable the interrupt generation */
+	if (tsl256x_interrupt_ctrls(&interr, &tsl256x_handle->periods))
+		return -EIO;
+
+	return 0;
+}
+
+static int tsl256x_set_power(unsigned int status)
+{
+	int ret;
+
+	if (status) {
+		ret = tsl256x_setup();
+		if (ret)
+			return ret;
+	}
+
+	status = status ? TSL256X_POWER_ON : TSL256X_POWER_OFF;
+	ret = tsl256x_exec_writebyte(TSL256X_REG_CTRL, &status);
+
+	return ret;
+}
+
+static int tsl256x_get_power(unsigned int *status)
+{
+	if (tsl256x_exec_readbyte(TSL256X_REG_CTRL, status))
+		return -EIO;
+
+	*status = ((*status & TSL256X_POWER_MASK) == TSL256X_POWER_ON) ? 1 : 0;
+
+	return 0;
+}
+
+static int tsl256x_get_raw_data(unsigned int *ch0, unsigned int *ch1)
+{
+	if (!ch0)
+		return -1;
+
+	if (tsl256x_exec_readword(TSL256X_REG_DATA0, ch0))
+		return -EIO;
+
+	if (ch1) {
+		if (tsl256x_exec_readword(TSL256X_REG_DATA1, ch1))
+			return -EIO;
+	}
+
+	return 0;
+}
+
+static int tsl256x_set_thresholds(const unsigned int *ch0)
+{
+	unsigned int tlow, thigh;
+
+	tlow = (*ch0 * tsl256x_handle->defaults[0]) / 100;
+	thigh = ((*ch0 * tsl256x_handle->defaults[1]) / 100) + 1;
+
+	if (thigh > 0xffff)
+		thigh = 0xffff;
+
+	if (tsl256x_exec_writeword(TSL256X_REG_TLOW, &tlow) ||
+		tsl256x_exec_writeword(TSL256X_REG_THIGH, &thigh))
+		return -EIO;
+
+	return 0;
+}
+
+#define MAX_LUX 1500
+static void tsl256x_calculate_lux(const u32 ch0, const u32 ch1,
+				unsigned int *integ, unsigned int *fract)
+{
+	/* the raw output from the sensor is just a "count" value, as
+	   it is the result of the integration of the analog sensor
+	   signal, the counts-to-lux curve (and its approximation can
+	   be found on the datasheet.
+	*/
+	const struct tsl256x_coeff *coeff = tsl256x_handle->coeff_table;
+	u32 ratio, temp, integer, fractional;
+
+	if (ch0 >= 65535 || ch1 >= 65535)
+		goto saturation;
+
+	/* STEP 1: ratio calculation, for ch0 & ch1 coeff selection */
+
+	/* protect against division by 0 */
+	ratio = ch0 ? ((ch1 << (LUX_SHIFT_BITS + 1)) / ch0) : UINT_MAX;
+	/* round the ratio value */
+	ratio = ratio == UINT_MAX ? ratio : (ratio + 1) >> 1;
+
+	/* coeff selection rule */
+	while (coeff->ratio < ratio)
+		coeff++;
+
+	/* STEP 2: lux calculation formula using the right coeffcients */
+	temp = (ch0 * coeff->ch0) - (ch1 * coeff->ch1);
+	/* the sensor is placed under a plastic or glass cover which filters
+	   a certain ammount of light (depending on that particular material).
+	   To have an accurate reading, we need to compensate for this loss,
+	   multiplying for compensation parameter, taken from the DSDT.
+	*/
+	temp *= tsl256x_handle->defaults[3] / 10;
+
+	/* STEP 3: separate integer and fractional part */
+	/* remove the integer part and multiply for the 10^N, N decimals  */
+	fractional = (temp % (1 << LUX_SHIFT_BITS)) * 100; /* two decimals */
+	/* scale down the value */
+	fractional >>= LUX_SHIFT_BITS;
+
+	/* strip off fractional portion to obtain the integer part */
+	integer = temp >> LUX_SHIFT_BITS;
+
+	if (integer > MAX_LUX)
+		goto saturation;
+
+	*integ = integer;
+	*fract = fractional;
+
+	return;
+
+saturation:
+	*integ = MAX_LUX;
+	*fract = 0;
+}
+
+static void tsl256x_calculate_kelvin(const u32 *ch0, const u32 *ch1,
+					unsigned int *temperature)
+{
+	const struct tsl256x_coeff *coeff = tsl256x_handle->coeff_table;
+	u32 ratio;
+
+	/* protect against division by 0 */
+	ratio = *ch0 ? ((*ch1 << (LUX_SHIFT_BITS + 1)) / *ch0) : UINT_MAX;
+	/* round the ratio value */
+	ratio = (ratio + 1) >> 1;
+
+	/* coeff selection rule */
+	while (coeff->ratio < ratio)
+		coeff++;
+
+	*temperature = ratio ? coeff->ka / ratio + coeff->kb : 0;
+}
+
+static int tsl256x_get_lux(unsigned int *integ, unsigned int *fract)
+{
+	int ret = 0;
+	unsigned int ch0, ch1;
+
+	if (!integ || !fract)
+		return -1;
+
+	ret = tsl256x_get_raw_data(&ch0, &ch1);
+	if (!ret)
+		tsl256x_calculate_lux(ch0, ch1, integ, fract);
+
+	return ret;
+}
+
+static int tsl256x_get_kelvin(unsigned int *temperature)
+{
+	int ret = -1;
+	unsigned int ch0, ch1;
+
+	if (!temperature)
+		return ret;
+
+	ret = tsl256x_get_raw_data(&ch0, &ch1);
+	if (!ret)
+		tsl256x_calculate_kelvin(&ch0, &ch1, temperature);
+
+	return ret;
+}
+
+static int tsl256x_get_id(char *model, unsigned int *id, bool *cs)
+{
+	int ret;
+	unsigned int result;
+	char *name = NULL;
+	bool unknown = false;
+	bool type_cs = false;
+
+	ret = tsl256x_exec_readbyte(TSL256X_REG_ID, &result);
+	if (ret)
+		return ret;
+
+	switch ((result >> 0x04) & 0x0F) {
+	case 5:
+		name = "TAOS TSL2561";
+		break;
+	case 4:
+		name = "TAOS TSL2560";
+		break;
+	case 3:
+		name = "TAOS TSL2563";
+		break;
+	case 2:
+		name = "TAOS TSL2562";
+		break;
+	case 1:
+		type_cs = true;
+		name = "TAOS TSL2561CS";
+		break;
+	case 0:
+		type_cs = true;
+		name = "TAOS TSL2560CS";
+		break;
+	default:
+		unknown = true;
+		break;
+	}
+
+	if (id)
+		*id = result;
+	if (cs)
+		*cs = type_cs;
+	if (model && name)
+		strcpy(model, name);
+
+	return unknown;
+}
+
+static int tsl256x_event_handler(void)
+{
+	unsigned int ch0, interr = 1;
+
+	/* wait for the EC to clear the interrupt */
+/*      schedule_timeout_interruptible(msecs_to_jiffies(100));	*/
+	/* ...or force the interrupt clear immediately */
+	sony_call_snc_handle(sony_als->handle, 0x04C60500, &interr);
+
+	/* read the raw data */
+	tsl256x_get_raw_data(&ch0, NULL);
+
+	/* set the thresholds */
+	tsl256x_set_thresholds(&ch0);
+
+	/* enable interrupt */
+	tsl256x_interrupt_ctrls(&interr, NULL);
+
+	return 0;
+}
+
+static int tsl256x_init(const u8 defaults[])
+{
+	unsigned int id;
+	int ret = 0;
+	bool cs; /* if CS package choose CS coefficients */
+	char model[64];
+
+	/* detect the device */
+	ret = tsl256x_get_id(model, &id, &cs);
+	if (ret < 0)
+		return ret;
+	if (ret) {
+		dprintk("unsupported ALS found (unknown model "
+			"number %u rev. %u\n", id >> 4, id & 0x0F);
+		return ret;
+	} else {
+		dprintk("found ALS model number %u rev. %u (%s)\n",
+				id >> 4, id & 0x0F, model);
+	}
+
+	tsl256x_handle = kzalloc(sizeof(struct tsl256x_data), GFP_KERNEL);
+	if (!tsl256x_handle)
+		return -ENOMEM;
+
+	tsl256x_handle->defaults = kzalloc(sizeof(u8) * 4, GFP_KERNEL);
+	if (!tsl256x_handle->defaults) {
+		kfree(tsl256x_handle);
+		return -ENOMEM;
+	}
+
+	/* populate the device data */
+	tsl256x_handle->defaults[0] = defaults[3];  /* low threshold % */
+	tsl256x_handle->defaults[1] = defaults[4];  /* high threshold % */
+	tsl256x_handle->defaults[2] = defaults[9];  /* sensor interrupt rate */
+	tsl256x_handle->defaults[3] = defaults[10]; /* light compensat. rate */
+	tsl256x_handle->gaintime = 0x12;
+	tsl256x_handle->periods = defaults[9];
+	tsl256x_handle->coeff_table = cs ? tsl256x_coeff_cs : tsl256x_coeff_fn;
+
+	ret = tsl256x_setup();
+
+	return ret;
+}
+
+static int tsl256x_exit(void)
+{
+	unsigned int interr = 0, periods = tsl256x_handle->defaults[2];
+
+	/* disable the interrupt generation, restore defaults */
+	tsl256x_interrupt_ctrls(&interr, &periods);
+
+	tsl256x_handle->coeff_table = NULL;
+	kfree(tsl256x_handle->defaults);
+	tsl256x_handle->defaults = NULL;
+	kfree(tsl256x_handle);
+
+	return 0;
+}
+
+/* TAOS TSL256x specific ops */
+static const struct als_device_ops tsl256x_ops = {
+	.init = tsl256x_init,
+	.exit = tsl256x_exit,
+	.event_handler = tsl256x_event_handler,
+	.set_power = tsl256x_set_power,
+	.get_power = tsl256x_get_power,
+	.get_lux = tsl256x_get_lux,
+	.get_kelvin = tsl256x_get_kelvin,
+};
+
+/* unknown ALS sensors controlled by the EC present on newer Vaios */
+static inline int ngals_get_raw_data(unsigned int *data)
+{
+	if (sony_call_snc_handle(sony_als->handle, 0x1000, data))
+		return -EIO;
+
+	return 0;
+}
+
+static int ngals_get_lux(unsigned int *integ, unsigned int *fract)
+{
+	unsigned int data;
+
+	if (sony_call_snc_handle(sony_als->handle, 0x1000, &data))
+		return -EIO;
+
+	/* if we have a valid lux data */
+	if (!!(data & 0xff0000) == 0x01) {
+		*integ = 0xffff & data;
+		*fract = 0;
+	} else {
+		return -1;
+	}
+
+	return 0;
+}
+
+static const struct als_device_ops ngals_ops = {
+	.init = NULL,
+	.exit = NULL,
+	.event_handler = NULL,
+	.set_power = NULL,
+	.get_power = NULL,
+	.get_lux = ngals_get_lux,
+	.get_kelvin = NULL,
+};
+
+/*	ALS common data and functions	*/
+static int sony_nc_als_event_handler(void)
+{
+	/* call the device handler */
+	if (sony_als->ops->event_handler)
+		sony_als->ops->event_handler();
+
+	return 0;
+}
+
+static int sony_nc_als_power_set(unsigned int status)
+{
+	if (!sony_als->ops->set_power)
+		return -EPERM;
+
+	if (sony_als->ops->set_power(status))
+		return -EIO;
+
+	sony_als->power = status;
+
+	return 0;
+}
+
+static int sony_nc_als_managed_set(unsigned int status)
+{
+	int ret = 0;
+	unsigned int result, cmd;
+	static bool was_on;
+
+	/*  turn on/off the event notification
+	 *  (and enable als_backlight writes)
+	 */
+	cmd = sony_als->handle == 0x0143 ? 0x2200 : 0x0900;
+	if (sony_call_snc_handle(sony_als->handle,
+		(status << 0x10) | cmd, &result))
+		return -EIO;
+
+	sony_als->managed = status;
+
+	/* turn on the ALS; this will also enable the interrupt generation */
+	if (status) /* store the power state else check the previous state */
+		was_on = sony_als->power;
+	else if (was_on)
+		return 0;
+
+	ret = sony_nc_als_power_set(status);
+	if (ret == -EPERM) /* new models do not allow power control */
+		ret = 0;
+
+	return ret;
+}
+
+static unsigned int level;
+static int sony_nc_als_get_brightness(struct backlight_device *bd)
+{
+	if (bd->props.brightness != level)
+		dprintk("bd->props.brightness != level\n");
+
+	return level;
+}
+
+static int sony_nc_als_update_status(struct backlight_device *bd)
+{
+	unsigned int value, result;
+
+	if (sony_als->managed) {
+		if (bd->props.brightness != level) {
+			char *env[2] = { "ALS=2", NULL};
+			kobject_uevent_env(&sony_nc_acpi_device->dev.kobj,
+						KOBJ_CHANGE, env);
+
+			dprintk("generating ALS event 3 (reason: 2)\n");
+			acpi_bus_generate_proc_event(sony_nc_acpi_device,
+					3, 2);
+			acpi_bus_generate_netlink_event(
+					sony_nc_acpi_device->pnp.device_class,
+					dev_name(&sony_nc_acpi_device->dev),
+					3, 2);
+		}
+	} else {
+		unsigned int cmd;
+
+		value = sony_als->levels[bd->props.brightness];
+		cmd = sony_als->handle == 0x0143 ? 0x3000 : 0x0100;
+		if (sony_call_snc_handle(sony_als->handle,
+					(value << 0x10) | cmd, &result))
+			return -EIO;
+	}
+
+	level = bd->props.brightness;
+
+	return level;
+}
+
+/*	ALS sys interface	*/
+static ssize_t sony_nc_als_power_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	int status;
+
+	if (!sony_als->ops->get_power)
+		return -EPERM;
+
+	if (sony_als->ops->get_power(&status))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", status);
+
+	return count;
+}
+
+static ssize_t sony_nc_als_power_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	int ret;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+
+	if (strict_strtoul(buffer, 10, &value) || value > 1)
+		return -EINVAL;
+
+	/* no action if already set */
+	if (value == sony_als->power)
+		return count;
+
+	ret = sony_nc_als_power_set(value);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t sony_nc_als_managed_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int status, cmd;
+
+	cmd = sony_als->handle == 0x0143 ? 0x2100 : 0x0A00;
+	if (sony_call_snc_handle(sony_als->handle, cmd, &status))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", status & 0x01);
+
+	return count;
+}
+
+static ssize_t sony_nc_als_managed_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+
+	if (strict_strtoul(buffer, 10, &value) || value > 1)
+		return -EINVAL;
+
+	if (sony_als->managed != value) {
+		int ret = sony_nc_als_managed_set(value);
+		if (ret)
+			return ret;
+	}
+
+	return count;
+}
+
+static ssize_t sony_nc_als_lux_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int integ = 0, fract = 0;
+
+	if (sony_als->power)
+		/* sony_als->ops->get_lux is mandatory, no check */
+		sony_als->ops->get_lux(&integ, &fract);
+
+	count = snprintf(buffer, PAGE_SIZE, "%u.%.2u\n", integ, fract);
+
+	return count;
+}
+
+static ssize_t sony_nc_als_parameters_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int i, num;
+	u8 *list;
+
+	if (!strcmp(attr->attr.name, "als_defaults")) {
+		list = sony_als->defaults;
+		num = sony_als->defaults_num;
+	} else { /* als_backlight_levels */
+		list = sony_als->levels;
+		num = sony_als->levels_num;
+	}
+
+	for (i = 0; i < num; i++)
+		count += snprintf(buffer + count, PAGE_SIZE - count,
+				"0x%.2x ", list[i]);
+
+	count += snprintf(buffer + count, PAGE_SIZE - count, "\n");
+
+	return count;
+}
+
+static ssize_t sony_nc_als_backlight_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result, cmd;
+
+	cmd = sony_als->handle == 0x0143 ? 0x3100 : 0x0200;
+	if (sony_call_snc_handle(sony_als->handle, cmd, &result))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", result & 0xff);
+
+	return count;
+}
+
+static ssize_t sony_nc_als_backlight_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned long value;
+	unsigned int result, cmd, max = sony_als->levels_num - 1;
+
+	if (count > 31)
+		return -EINVAL;
+
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
+
+	if (!sony_als->managed)
+		return -EPERM;
+
+	/* verify that the provided value falls inside the model
+	   specific backlight range */
+	if ((value < sony_als->levels[0])
+			|| (value > sony_als->levels[max]))
+		return -EINVAL;
+
+	cmd = sony_als->handle == 0x0143 ? 0x3000 : 0x0100;
+	if (sony_call_snc_handle(sony_als->handle, (value << 0x10) | cmd,
+				&result))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t sony_nc_als_kelvin_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int kelvin = 0;
+
+	if (sony_als->ops->get_kelvin && sony_als->power)
+		sony_als->ops->get_kelvin(&kelvin);
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", kelvin);
+
+	return count;
+}
+
+/*	ALS attach/detach functions	*/
+static int sony_nc_als_setup(struct platform_device *pd, unsigned int handle)
+{
+	int i = 0;
+
+	/* check the device presence */
+	if (handle == 0x0137) {
+		unsigned int result;
+
+		if (sony_call_snc_handle(handle, 0xB00, &result))
+			return -EIO;
+
+		if (!(result & 0x01)) {
+			pr_info("no ALS present\n");
+			return 0;
+		}
+	}
+
+	sony_als = kzalloc(sizeof(struct sony_als_device), GFP_KERNEL);
+	if (!sony_als)
+		return -ENOMEM;
+
+	/* set model specific data */
+	/* if handle 0x012f or 0x0137 use tsl256x_ops, else new als controls */
+	if (handle == 0x0143) {
+		sony_als->ops = &ngals_ops;
+		sony_als->levels_num = 16;
+		sony_als->defaults_num = 9;
+	} else {
+		sony_als->ops = &tsl256x_ops;
+		sony_als->levels_num = 9;
+		sony_als->defaults_num = 13;
+	}
+	/* backlight levels are the first levels_num values, the remaining
+	   defaults_num values are default settings for als regulation
+	*/
+	sony_als->levels = sony_als->parameters;
+	sony_als->defaults = sony_als->parameters + sony_als->levels_num;
+
+	sony_als->handle = handle;
+
+	/* get power state */
+	if (sony_als->ops->get_power) {
+		if (sony_als->ops->get_power(&sony_als->power))
+			pr_warn("unable to retrieve the power status\n");
+	}
+
+	/* set managed to 0, userspace daemon should enable it */
+	sony_nc_als_managed_set(0);
+
+	/* get ALS parameters */
+	if (sony_call_snc_handle_buffer(sony_als->handle, 0x0000,
+		sony_als->parameters, ALS_TABLE_SIZE) < 0)
+		goto nosensor;
+
+	/* initial device configuration */
+	if (sony_als->ops->init)
+		if (sony_als->ops->init(sony_als->defaults)) {
+			pr_warn("ALS setup failed\n");
+			goto nosensor;
+		}
+
+	/* set up the sys interface */
+
+	/* notifications and backlight enable control file */
+	sysfs_attr_init(&sony_als->attrs[0].attr);
+	sony_als->attrs[0].attr.name = "als_managed";
+	sony_als->attrs[0].attr.mode = S_IRUGO | S_IWUSR;
+	sony_als->attrs[0].show = sony_nc_als_managed_show;
+	sony_als->attrs[0].store = sony_nc_als_managed_store;
+	/* lux equivalent value */
+	sysfs_attr_init(&sony_als->attrs[1].attr);
+	sony_als->attrs[1].attr.name = "als_lux";
+	sony_als->attrs[1].attr.mode = S_IRUGO;
+	sony_als->attrs[1].show = sony_nc_als_lux_show;
+	/* ALS default parameters */
+	sysfs_attr_init(&sony_als->attrs[2].attr);
+	sony_als->attrs[2].attr.name = "als_defaults";
+	sony_als->attrs[2].attr.mode = S_IRUGO;
+	sony_als->attrs[2].show = sony_nc_als_parameters_show;
+	/* ALS default backlight levels */
+	sysfs_attr_init(&sony_als->attrs[3].attr);
+	sony_als->attrs[3].attr.name = "als_backlight_levels";
+	sony_als->attrs[3].attr.mode = S_IRUGO;
+	sony_als->attrs[3].show = sony_nc_als_parameters_show;
+	/* als backlight control */
+	sysfs_attr_init(&sony_als->attrs[4].attr);
+	sony_als->attrs[4].attr.name = "als_backlight";
+	sony_als->attrs[4].attr.mode = S_IRUGO | S_IWUSR;
+	sony_als->attrs[4].show = sony_nc_als_backlight_show;
+	sony_als->attrs[4].store = sony_nc_als_backlight_store;
+
+	sony_als->attrs_num = 5;
+	/* end mandatory sys interface */
+
+	if (sony_als->ops->get_power || sony_als->ops->set_power) {
+		int i = sony_als->attrs_num++;
+
+		/* als power control */
+		sysfs_attr_init(&sony_als->attrs[i].attr);
+		sony_als->attrs[i].attr.name = "als_power";
+		sony_als->attrs[i].attr.mode = S_IRUGO | S_IWUSR;
+		sony_als->attrs[i].show = sony_nc_als_power_show;
+		sony_als->attrs[i].store = sony_nc_als_power_store;
+	}
+
+	if (sony_als->ops->get_kelvin) {
+		int i = sony_als->attrs_num++;
+
+		/* light temperature */
+		sysfs_attr_init(&sony_als->attrs[i].attr);
+		sony_als->attrs[i].attr.name = "als_kelvin";
+		sony_als->attrs[i].attr.mode = S_IRUGO;
+		sony_als->attrs[i].show = sony_nc_als_kelvin_show;
+	}
+
+	/* everything or nothing, otherwise unable to control the ALS */
+	for (; i < sony_als->attrs_num; i++) {
+		if (device_create_file(&pd->dev, &sony_als->attrs[i]))
+			goto attrserror;
+	}
+
+	return 0;
+
+attrserror:
+	for (; i > 0; i--)
+		device_remove_file(&pd->dev, &sony_als->attrs[i]);
+nosensor:
+	kfree(sony_als);
+	sony_als = NULL;
+
+	return -1;
+}
+
+static void sony_nc_als_resume(void)
+{
+	if (sony_als->managed) /* it restores the power state too */
+		sony_nc_als_managed_set(1);
+	else if (sony_als->power)
+		sony_nc_als_power_set(1);
+}
+
+static int sony_nc_als_cleanup(struct platform_device *pd)
+{
+	if (sony_als) {
+		int i;
+
+		for (i = 0; i < sony_als->attrs_num; i++)
+			device_remove_file(&pd->dev, &sony_als->attrs[i]);
+
+		/* disable the events notification */
+		if (sony_als->managed)
+			if (sony_nc_als_managed_set(0))
+				pr_info("ALS notifications disable failed\n");
+
+		if (sony_als->power)
+			if (sony_nc_als_power_set(0))
+				pr_info("ALS power off failed\n");
+
+		if (sony_als->ops->exit)
+			if (sony_als->ops->exit())
+				pr_info("ALS device cleaning failed\n");
+
+		kfree(sony_als);
+		sony_als = NULL;
+	}
+
+	return 0;
+}
+/*	end ALS code	*/
+
+/* Keyboard backlight feature */
+static struct sony_kbdbl_data {
+	unsigned int handle;
+	unsigned int base;
+	unsigned int mode;
+	unsigned int timeout;
+	struct device_attribute mode_attr;
+	struct device_attribute timeout_attr;
+} *sony_kbdbl;
+
+static int __sony_nc_kbd_backlight_mode_set(u8 value)
+{
+	unsigned int result;
+
+	if (value > 1)
+		return -EINVAL;
+
+	if (sony_call_snc_handle(sony_kbdbl->handle, (value << 0x10) |
+				(sony_kbdbl->base), &result))
+		return -EIO;
+
+	sony_kbdbl->mode = value;
+
+	/* Try to turn the light on/off immediately */
+	sony_call_snc_handle(sony_kbdbl->handle, (value << 0x10) |
+				(sony_kbdbl->base + 0x100), &result);
+
+	return 0;
+}
+
+static ssize_t sony_nc_kbd_backlight_mode_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	int ret = 0;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
+
+	ret = __sony_nc_kbd_backlight_mode_set(value);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t sony_nc_kbd_backlight_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", sony_kbdbl->mode);
+
+	return count;
+}
+
+static int __sony_nc_kbd_backlight_timeout_set(u8 value)
+{
+	unsigned int result;
+
+	if (value > 3)
+		return -EINVAL;
+
+	if (sony_call_snc_handle(sony_kbdbl->handle, (value << 0x10) |
+				(sony_kbdbl->base + 0x200), &result))
+		return -EIO;
+
+	sony_kbdbl->timeout = value;
+
+	return 0;
+}
+
+static ssize_t sony_nc_kbd_backlight_timeout_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	int ret = 0;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
+
+	ret = __sony_nc_kbd_backlight_timeout_set(value);
+	if (ret < 0)
+		return ret;
+
+	return count;
+}
+
+static ssize_t sony_nc_kbd_backlight_timeout_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", sony_kbdbl->timeout);
+
+	return count;
+}
+
+static int sony_nc_kbd_backlight_setup(struct platform_device *pd,
+					unsigned int handle)
+{
+	unsigned int result, base_cmd;
+	bool found = false;
+
+	/* verify the kbd backlight presence, some models do not have it */
+	if (handle == 0x0137) {
+		if (sony_call_snc_handle(handle, 0x0B00, &result))
+			return -EIO;
+
+		found = !!(result & 0x02);
+		base_cmd = 0x0C00;
+	} else {
+		if (sony_call_snc_handle(handle, 0x0100, &result))
+			return -EIO;
+
+		found = result & 0x01;
+		base_cmd = 0x4000;
+	}
+
+	if (!found) {
+		dprintk("no backlight keyboard found\n");
+		return 0;
+	}
+
+	sony_kbdbl = kzalloc(sizeof(*sony_kbdbl), GFP_KERNEL);
+	if (!sony_kbdbl)
+		return -ENOMEM;
+
+	sysfs_attr_init(&sony_kbdbl->mode_attr.attr);
+	sony_kbdbl->mode_attr.attr.name = "kbd_backlight";
+	sony_kbdbl->mode_attr.attr.mode = S_IRUGO | S_IWUSR;
+	sony_kbdbl->mode_attr.show = sony_nc_kbd_backlight_mode_show;
+	sony_kbdbl->mode_attr.store = sony_nc_kbd_backlight_mode_store;
+
+	sysfs_attr_init(&sony_kbdbl->timeout_attr.attr);
+	sony_kbdbl->timeout_attr.attr.name = "kbd_backlight_timeout";
+	sony_kbdbl->timeout_attr.attr.mode = S_IRUGO | S_IWUSR;
+	sony_kbdbl->timeout_attr.show = sony_nc_kbd_backlight_timeout_show;
+	sony_kbdbl->timeout_attr.store = sony_nc_kbd_backlight_timeout_store;
+
+	if (device_create_file(&pd->dev, &sony_kbdbl->mode_attr))
+		goto outkzalloc;
+
+	if (device_create_file(&pd->dev, &sony_kbdbl->timeout_attr))
+		goto outmode;
+
+	sony_kbdbl->handle = handle;
+	sony_kbdbl->base = base_cmd;
+
+	__sony_nc_kbd_backlight_mode_set(kbd_backlight);
+	__sony_nc_kbd_backlight_timeout_set(kbd_backlight_timeout);
+
+	return 0;
+
+outmode:
+	device_remove_file(&pd->dev, &sony_kbdbl->mode_attr);
+outkzalloc:
+	kfree(sony_kbdbl);
+	sony_kbdbl = NULL;
+	return -1;
+}
+
+static int sony_nc_kbd_backlight_cleanup(struct platform_device *pd)
+{
+	if (sony_kbdbl) {
+		unsigned int result;
+
+		device_remove_file(&pd->dev, &sony_kbdbl->mode_attr);
+		device_remove_file(&pd->dev, &sony_kbdbl->timeout_attr);
+
+		/* restore the default hw behaviour */
+		sony_call_snc_handle(sony_kbdbl->handle,
+				sony_kbdbl->base | 0x10000, &result);
+		sony_call_snc_handle(sony_kbdbl->handle,
+				sony_kbdbl->base + 0x200, &result);
+
+		kfree(sony_kbdbl);
+		sony_kbdbl = NULL;
+	}
+	return 0;
+}
+
+static void sony_nc_kbd_backlight_resume(void)
+{
+	unsigned int result;
+
+	if (!sony_kbdbl)
+		return;
+
+	if (sony_kbdbl->mode == 0)
+		sony_call_snc_handle(sony_kbdbl->handle,
+				sony_kbdbl->base, &result);
+
+	if (sony_kbdbl->timeout != 0)
+		sony_call_snc_handle(sony_kbdbl->handle,
+				(sony_kbdbl->base + 0x200) |
+				(sony_kbdbl->timeout << 0x10), &result);
+}
+
+/*	GSensor, HDD Shock Protection	*/
+enum axis {
+	X_AXIS = 4,	/* frontal  */
+	Y_AXIS,		/* lateral  */
+	Z_AXIS		/* vertical */
+};
+
+static struct sony_gsensor_device {
+	unsigned int handle;
+	unsigned int attrs_num;
+	struct device_attribute *attrs;
+} *sony_gsensor;
+
+/* the EC uses pin #11 of the SATA power connector to command the
+   immediate idle feature; however some drives do not implement it
+   and pin #11 is NC. Let's verify, otherwise no automatic
+   protection is possible by the hardware
+*/
+static int sony_nc_gsensor_support_get(unsigned int *support)
+{
+	unsigned int result;
+
+	if (sony_call_snc_handle(sony_gsensor->handle, 0x0200, &result))
+		return -EIO;
+
+	*support = sony_gsensor->handle == 0x0134
+			? !!(result & 0x20)
+			: !!(result & 0x01);
+
+	return 0;
+}
+
+static int sony_nc_gsensor_status_set(int value)
+{
+	unsigned int result, capable, reg, arg;
+	bool update = false;
+
+	if (sony_nc_gsensor_support_get(&capable))
+		return -EIO;
+
+	if (!capable)
+		pr_warn("hardware protection not available, the HDD"
+			       " do not support this feature\n");
+
+	/* do not return immediately even though there is no HW
+	 * capability, userspace can thus receive the shock
+	 * notifications and call the ATA7 immediate idle command to
+	 * unload the heads. Just return after enabling notifications
+	*/
+	reg = sony_gsensor->handle == 0x0134 ?
+		(!value << 0x08) : (value << 0x10);
+
+	if (sony_call_snc_handle(sony_gsensor->handle, reg, &result))
+		return -EIO;
+
+	if (!capable)
+		return 0;
+
+	/* if the requested protection setting is different
+	   from the current one
+	*/
+	reg = sony_gsensor->handle == 0x0134 ? 0x0200 : 0x0400;
+	if (sony_call_snc_handle(sony_gsensor->handle, reg, &result))
+		return -EIO;
+
+	if (sony_gsensor->handle == 0x0134) {
+		if (!!(result & 0x04) != value) {
+			arg = (result & 0x1B) | (value << 0x02);
+			update = true;
+		}
+	} else {
+		if ((result & 0x01) != value) {
+			arg = value;
+			update = true;
+		}
+	}
+
+	if (update && sony_call_snc_handle(sony_gsensor->handle,
+			(arg << 0x10) | 0x0300, &result))
+		return -EIO;
+
+	return 0;
+}
+
+static int sony_nc_gsensor_axis_get(enum axis name)
+{
+	unsigned int result;
+
+	if (sony_call_snc_handle(sony_gsensor->handle, name << 0x08, &result))
+		return -EIO;
+
+	return result;
+}
+
+/*			G sensor sys interface			*/
+static ssize_t sony_nc_gsensor_type_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(sony_gsensor->handle, 0x0200, &result))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", (result >> 0x03) & 0x03);
+
+	return count;
+}
+
+static ssize_t sony_nc_gsensor_type_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	/*
+	 *  axis out type control file:
+	 *  0: raw values, 1: acc values 2: threshold values
+	 */
+	unsigned int result;
+	unsigned long value;
+
+	/* sanity checks and conversion */
+	if (count > 31 || strict_strtoul(buffer, 10, &value) || value > 2)
+		return -EINVAL;
+
+	value <<= 0x03;
+
+	/* retrieve the current state / settings */
+	if (sony_call_snc_handle(sony_gsensor->handle, 0x0200, &result))
+		return -EIO;
+
+	if ((result & 0x18) != value) {
+		/* the last 3 bits need to be preserved */
+		value |= (result & 0x07);
+
+		if (sony_call_snc_handle(sony_gsensor->handle,
+				(value << 0x10) | 0x0300, &result))
+				return -EIO;
+	}
+
+	return count;
+}
+
+static ssize_t sony_nc_gsensor_axis_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+	enum axis arg;
+
+	/* file being read for axis selection */
+	if (!strcmp(attr->attr.name, "gsensor_xval"))
+		arg = X_AXIS;
+	else if (!strcmp(attr->attr.name, "gsensor_yval"))
+		arg = Y_AXIS;
+	else if (!strcmp(attr->attr.name, "gsensor_zval"))
+		arg = Z_AXIS;
+	else
+		return count;
+
+	result = sony_nc_gsensor_axis_get(arg);
+	if (result < 0)
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", result);
+
+	return count;
+}
+
+static ssize_t sony_nc_gsensor_status_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_gsensor->handle == 0x0134) {
+		if (sony_call_snc_handle(sony_gsensor->handle, 0x0200,
+					&result))
+			return -EIO;
+
+		result = !!(result & 0x04);
+	} else {
+		if (sony_call_snc_handle(sony_gsensor->handle, 0x0400,
+					&result))
+			return -EIO;
+
+		result &= 0x01;
+	}
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", result);
+
+	return count;
+}
+
+static ssize_t sony_nc_gsensor_status_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	int ret;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value) || value > 1)
+		return -EINVAL;
+
+	ret = sony_nc_gsensor_status_set(value);
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static ssize_t sony_nc_gsensor_sensitivity_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(sony_gsensor->handle, 0x0200, &result))
+		return -EINVAL;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", result & 0x03);
+	return count;
+}
+
+static ssize_t sony_nc_gsensor_sensitivity_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned int result;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value) || value > 2)
+		return -EINVAL;
+
+	/* retrieve the other parameters to be stored as well */
+	if (sony_call_snc_handle(sony_gsensor->handle, 0x0200, &result))
+		return -EIO;
+	value |= (result & 0x1C); /* preserve only the needed bits */
+
+	if (sony_call_snc_handle(sony_gsensor->handle, (value << 0x10)
+		| 0x0300, &result))
+		return -EIO;
+
+	return count;
+}
+
+static int sony_nc_gsensor_setup(struct platform_device *pd,
+					unsigned int handle)
+{
+	int i, enable, support;
+
+	sony_gsensor = kzalloc(sizeof(struct sony_gsensor_device), GFP_KERNEL);
+	if (!sony_gsensor)
+		return -ENOMEM;
+
+	sony_gsensor->handle = handle;
+	sony_gsensor->attrs_num = handle == 0x0134 ? 6 : 1;
+
+	sony_gsensor->attrs = kzalloc(sizeof(struct device_attribute)
+				* sony_gsensor->attrs_num, GFP_KERNEL);
+	if (!sony_gsensor->attrs)
+		goto memerror;
+
+	/* check the storing device support */
+	if (sony_nc_gsensor_support_get(&support))
+		return -EIO;
+
+	/* enable the HDD protection and notification by default
+	   when hardware driven protection is possible */
+	enable = support ? 1 : force_shock_notifications;
+	if (sony_nc_gsensor_status_set(enable))
+		if (enable)
+			pr_warn("failed to enable the HDD shock protection\n");
+
+	/* activation control	*/
+	sysfs_attr_init(&sony_gsensor->attrs[0].attr);
+	sony_gsensor->attrs[0].attr.name = "gsensor_protection";
+	sony_gsensor->attrs[0].attr.mode = S_IRUGO | S_IWUSR;
+	sony_gsensor->attrs[0].show = sony_nc_gsensor_status_show;
+	sony_gsensor->attrs[0].store = sony_nc_gsensor_status_store;
+
+	if (sony_gsensor->attrs_num > 1) {
+		/* sensitivity selection */
+		sysfs_attr_init(&sony_gsensor->attrs[1].attr);
+		sony_gsensor->attrs[1].attr.name = "gsensor_sensitivity";
+		sony_gsensor->attrs[1].attr.mode = S_IRUGO | S_IWUSR;
+		sony_gsensor->attrs[1].show = sony_nc_gsensor_sensitivity_show;
+		sony_gsensor->attrs[1].store =
+					sony_nc_gsensor_sensitivity_store;
+		/* x/y/z output selection */
+		sysfs_attr_init(&sony_gsensor->attrs[2].attr);
+		sony_gsensor->attrs[2].attr.name = "gsensor_val_type";
+		sony_gsensor->attrs[2].attr.mode = S_IRUGO | S_IWUSR;
+		sony_gsensor->attrs[2].show = sony_nc_gsensor_type_show;
+		sony_gsensor->attrs[2].store = sony_nc_gsensor_type_store;
+
+		sysfs_attr_init(&sony_gsensor->attrs[3].attr);
+		sony_gsensor->attrs[3].attr.name = "gsensor_xval";
+		sony_gsensor->attrs[3].attr.mode = S_IRUGO;
+		sony_gsensor->attrs[3].show = sony_nc_gsensor_axis_show;
+
+		sysfs_attr_init(&sony_gsensor->attrs[4].attr);
+		sony_gsensor->attrs[4].attr.name = "gsensor_yval";
+		sony_gsensor->attrs[4].attr.mode = S_IRUGO;
+		sony_gsensor->attrs[4].show = sony_nc_gsensor_axis_show;
+
+		sysfs_attr_init(&sony_gsensor->attrs[5].attr);
+		sony_gsensor->attrs[5].attr.name = "gsensor_zval";
+		sony_gsensor->attrs[5].attr.mode = S_IRUGO;
+		sony_gsensor->attrs[5].show = sony_nc_gsensor_axis_show;
+	}
+
+	for (i = 0; i < sony_gsensor->attrs_num; i++) {
+		if (device_create_file(&pd->dev, &sony_gsensor->attrs[i]))
+			goto attrserror;
+	}
+
+	return 0;
+
+attrserror:
+	for (; i > 0; i--)
+		device_remove_file(&pd->dev, &sony_gsensor->attrs[i]);
+
+	kfree(sony_gsensor->attrs);
+memerror:
+	kfree(sony_gsensor);
+	sony_gsensor = NULL;
+
+	return -1;
+}
+
+static int sony_nc_gsensor_cleanup(struct platform_device *pd)
+{
+	if (sony_gsensor) {
+		unsigned int i, result, reg;
+
+		for (i = 0; i < sony_gsensor->attrs_num; i++)
+			device_remove_file(&pd->dev, &sony_gsensor->attrs[i]);
+
+		/* disable the event generation,
+		 * preserve any other setting
+		 */
+		reg = sony_gsensor->handle == 0x0134 ? 0x0100 : 0x0000;
+
+		sony_call_snc_handle(sony_gsensor->handle, reg, &result);
+
+		kfree(sony_gsensor->attrs);
+		kfree(sony_gsensor);
+		sony_gsensor = NULL;
+	}
+
+	return 0;
+}
+/*			end G sensor code			*/
+
+static struct sony_battcare_data {
+	unsigned int handle;
+	struct device_attribute attrs[2];
+} *sony_battcare;
+
+static ssize_t sony_nc_battery_care_limit_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned int result, cmd;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
+
+	/*  limit values (2 bits):
+	 *  00 - none
+	 *  01 - 80%
+	 *  10 - 50%
+	 *  11 - 100%
+	 *
+	 *  bit 0: 0 disable BCL, 1 enable BCL
+	 *  bit 1: 1 tell to store the battery limit (see bits 6,7) too
+	 *  bits 2,3: reserved
+	 *  bits 4,5: store the limit into the EC
+	 *  bits 6,7: store the limit into the battery
+	 */
+
+	/*
+	 * handle 0x0115 should allow storing on battery too;
+	 * handle 0x0136 same as 0x0115 + health status;
+	 * handle 0x013f, same as 0x0136 but no storing on the battery
+	 *
+	 * Store only inside the EC for now, regardless the handle number
+	 */
+	switch (value) {
+	case 0:	/* disable */
+		cmd = 0x00;
+		break;
+	case 1: /* enable, 80% charge limit */
+		cmd = 0x11;
+		break;
+	case 2: /* enable, 50% charge limit */
+		cmd = 0x21;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (sony_call_snc_handle(sony_battcare->handle, (cmd << 0x10) | 0x0100,
+				&result))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t sony_nc_battery_care_limit_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result, status;
+
+	if (sony_call_snc_handle(sony_battcare->handle, 0x0000, &result))
+		return -EIO;
+
+	/* if disabled 0, else take the limit bits */
+	status = !(result & 0x01) ? 0 : ((result & 0x30) >> 0x04);
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", status);
+	return count;
+}
+
+static ssize_t sony_nc_battery_care_health_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int health;
+
+	if (sony_call_snc_handle(sony_battcare->handle, 0x0200, &health))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", health & 0xff);
+
+	return count;
+}
+
+static int sony_nc_battery_care_setup(struct platform_device *pd,
+					unsigned int handle)
+{
+	sony_battcare = kzalloc(sizeof(struct sony_battcare_data), GFP_KERNEL);
+	if (!sony_battcare)
+		return -ENOMEM;
+
+	sony_battcare->handle = handle;
+
+	sysfs_attr_init(&sony_battcare->attrs[0].attr);
+	sony_battcare->attrs[0].attr.name = "battery_care_limiter";
+	sony_battcare->attrs[0].attr.mode = S_IRUGO | S_IWUSR;
+	sony_battcare->attrs[0].show = sony_nc_battery_care_limit_show;
+	sony_battcare->attrs[0].store = sony_nc_battery_care_limit_store;
+
+	if (device_create_file(&pd->dev, &sony_battcare->attrs[0]))
+		goto outkzalloc;
+
+	if (handle == 0x0115) /* no health indication */
+		return 0;
+
+	sysfs_attr_init(&sony_battcare->attrs[1].attr);
+	sony_battcare->attrs[1].attr.name = "battery_care_health";
+	sony_battcare->attrs[1].attr.mode = S_IRUGO;
+	sony_battcare->attrs[1].show = sony_nc_battery_care_health_show;
+
+	if (device_create_file(&pd->dev, &sony_battcare->attrs[1]))
+		goto outlimiter;
+
+	return 0;
+
+outlimiter:
+	device_remove_file(&pd->dev, &sony_battcare->attrs[0]);
+outkzalloc:
+	kfree(sony_battcare);
+	sony_battcare = NULL;
+
+	return -1;
+}
+
+static int sony_nc_battery_care_cleanup(struct platform_device *pd)
+{
+	if (sony_battcare) {
+		device_remove_file(&pd->dev, &sony_battcare->attrs[0]);
+		if (sony_battcare->handle != 0x0115)
+			device_remove_file(&pd->dev, &sony_battcare->attrs[1]);
+
+		kfree(sony_battcare);
+		sony_battcare = NULL;
+	}
+
+	return 0;
+}
+
+static struct sony_thermal_data {
+	unsigned int mode;
+	unsigned int profiles;
+	struct device_attribute mode_attr;
+	struct device_attribute profiles_attr;
+} *sony_thermal;
+
+static int sony_nc_thermal_mode_set(unsigned int profile)
+{
+	unsigned int cmd, result;
+
+	/* to avoid the 1 value hole when only 2 profiles are available */
+	switch (profile) {
+	case 1: /* performance */
+		cmd = 2;
+		break;
+	case 2: /* silent */
+		cmd = 1;
+		break;
+	default: /* balanced */
+		cmd = 0;
+		break;
+	}
+
+	if (sony_call_snc_handle(0x0122, cmd << 0x10 | 0x0200, &result))
+		return -EIO;
+
+	sony_thermal->mode = profile;
+
+	return 0;
+}
+
+static int sony_nc_thermal_mode_get(unsigned int *profile)
+{
+	unsigned int result;
+
+	if (sony_call_snc_handle(0x0122, 0x0100, &result))
+		return -EIO;
+
+	/* to avoid the 1 value hole when only 2 profiles are available */
+	switch (result & 0xff) {
+	case 2: /* performance */
+		*profile = 1;
+		break;
+	case 1: /* silent */
+		*profile = 2;
+		break;
+	default: /* balanced */
+		*profile = 0;
+		break;
+	}
+
+	return 0;
+}
+
+static ssize_t sony_nc_thermal_profiles_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	return snprintf(buffer, PAGE_SIZE, "%u\n", sony_thermal->profiles);
+}
+
+static ssize_t sony_nc_thermal_mode_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value) ||
+		value > (sony_thermal->profiles - 1))
+		return -EINVAL;
+
+	if (sony_nc_thermal_mode_set(value))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t sony_nc_thermal_mode_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int profile;
+
+	if (sony_nc_thermal_mode_get(&profile))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", profile);
+
+	return count;
+}
+
+static int sony_nc_thermal_setup(struct platform_device *pd)
+{
+	sony_thermal = kzalloc(sizeof(struct sony_thermal_data), GFP_KERNEL);
+	if (!sony_thermal)
+		return -ENOMEM;
+
+	if (sony_call_snc_handle(0x0122, 0x0000, &sony_thermal->profiles)) {
+		pr_warn("unable to retrieve the available profiles\n");
+		goto outkzalloc;
+	}
+
+	if (sony_nc_thermal_mode_get(&sony_thermal->mode)) {
+		pr_warn("unable to retrieve the current profile");
+		goto outkzalloc;
+	}
+
+	sysfs_attr_init(&sony_thermal->profiles_attr.attr);
+	sony_thermal->profiles_attr.attr.name = "thermal_profiles";
+	sony_thermal->profiles_attr.attr.mode = S_IRUGO;
+	sony_thermal->profiles_attr.show = sony_nc_thermal_profiles_show;
+
+	sysfs_attr_init(&sony_thermal->mode_attr.attr);
+	sony_thermal->mode_attr.attr.name = "thermal_control";
+	sony_thermal->mode_attr.attr.mode = S_IRUGO | S_IWUSR;
+	sony_thermal->mode_attr.show = sony_nc_thermal_mode_show;
+	sony_thermal->mode_attr.store = sony_nc_thermal_mode_store;
+
+	if (device_create_file(&pd->dev, &sony_thermal->profiles_attr))
+		goto outkzalloc;
+
+	if (device_create_file(&pd->dev, &sony_thermal->mode_attr))
+		goto outprofiles;
+
+	return 0;
+
+outprofiles:
+	device_remove_file(&pd->dev, &sony_thermal->profiles_attr);
+outkzalloc:
+	kfree(sony_thermal);
+	sony_thermal = NULL;
+	return -1;
+}
+
+static int sony_nc_thermal_cleanup(struct platform_device *pd)
+{
+	if (sony_thermal) {
+		device_remove_file(&pd->dev, &sony_thermal->profiles_attr);
+		device_remove_file(&pd->dev, &sony_thermal->mode_attr);
+		kfree(sony_thermal);
+		sony_thermal = NULL;
+	}
+
+	return 0;
+}
+
+static void sony_nc_thermal_resume(void)
+{
+	unsigned int status;
+
+	sony_nc_thermal_mode_get(&status);
+
+	if (status != sony_thermal->mode)
+		sony_nc_thermal_mode_set(sony_thermal->mode);
+}
+
+static struct device_attribute *sony_lid;
+
+static ssize_t sony_nc_lid_resume_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned int result;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value) || value > 3)
+		return -EINVAL;
+
+	/* 00 <- disabled
+	   01 <- resume from S4
+	   10 <- resume from S3
+	   11 <- resume from S4 and S3
+	*/
+	/* we must set bit 1 and 2 (bit 0 is for S5), so shift one bit more */
+	if (sony_call_snc_handle(0x0119, value << 0x11 | 0x0100, &result))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t sony_nc_lid_resume_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(0x0119, 0x0000, &result))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", (result >> 1) & 0x03);
+
+	return count;
+}
+
+static int sony_nc_lid_resume_setup(struct platform_device *pd)
+{
+	sony_lid = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);
+	if (!sony_lid)
+		return -ENOMEM;
+
+	sysfs_attr_init(&sony_lid->attr);
+	sony_lid->attr.name = "lid_resume_control";
+	sony_lid->attr.mode = S_IRUGO | S_IWUSR;
+	sony_lid->show = sony_nc_lid_resume_show;
+	sony_lid->store = sony_nc_lid_resume_store;
+
+	if (device_create_file(&pd->dev, sony_lid)) {
+		kfree(sony_lid);
+		sony_lid = NULL;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sony_nc_lid_resume_cleanup(struct platform_device *pd)
+{
+	if (sony_lid) {
+		device_remove_file(&pd->dev, sony_lid);
+		kfree(sony_lid);
+		sony_lid = NULL;
+	}
+
+	return 0;
+}
+
+static struct device_attribute *sony_hsc;
+
+static ssize_t sony_nc_highspeed_charging_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned int result;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value) || value > 1)
+		return -EINVAL;
+
+	if (sony_call_snc_handle(0x0131, value << 0x10 | 0x0200, &result))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t sony_nc_highspeed_charging_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(0x0131, 0x0100, &result))
+		return -EIO;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", result & 0x01);
+
+	return count;
+}
+
+static int sony_nc_highspeed_charging_setup(struct platform_device *pd)
+{
+	unsigned int result;
+
+	if (sony_call_snc_handle(0x0131, 0x0000, &result) || !(result & 0x01)) {
+		pr_info("no High Speed Charging capability found\n");
+		return 0;
+	}
+
+	sony_hsc = kzalloc(sizeof(struct device_attribute), GFP_KERNEL);
+	if (!sony_hsc)
+		return -ENOMEM;
+
+	sysfs_attr_init(&sony_hsc->attr);
+	sony_hsc->attr.name = "battery_highspeed_charging";
+	sony_hsc->attr.mode = S_IRUGO | S_IWUSR;
+	sony_hsc->show = sony_nc_highspeed_charging_show;
+	sony_hsc->store = sony_nc_highspeed_charging_store;
+
+	if (device_create_file(&pd->dev, sony_hsc)) {
+		kfree(sony_hsc);
+		sony_hsc = NULL;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sony_nc_highspeed_charging_cleanup(struct platform_device *pd)
+{
+	if (sony_hsc) {
+		device_remove_file(&pd->dev, sony_hsc);
+		kfree(sony_hsc);
+		sony_hsc = NULL;
+	}
+
+	return 0;
+}
+
+static struct sony_tpad_device {
+	unsigned int handle;
+	struct device_attribute attr;
+} *sony_tpad;
+
+static ssize_t sony_nc_touchpad_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned int result;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value) || value > 1)
+		return -EINVAL;
+
+	/* sysfs: 0 disabled, 1 enabled; EC: 0 enabled, 1 disabled */
+	if (sony_call_snc_handle(sony_tpad->handle,
+				(!value << 0x10) | 0x100, &result))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t sony_nc_touchpad_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(sony_tpad->handle, 0x000, &result))
+		return -EINVAL;
+
+	/* 1 tpad off, 0 tpad on */
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", !(result & 0x01));
+	return count;
+}
+
+static int sony_nc_touchpad_setup(struct platform_device *pd,
+					unsigned int handle)
+{
+	sony_tpad = kzalloc(sizeof(struct sony_tpad_device), GFP_KERNEL);
+	if (!sony_tpad)
+		return -ENOMEM;
+
+	sony_tpad->handle = handle;
+
+	sysfs_attr_init(&sony_tpad->attr.attr);
+	sony_tpad->attr.attr.name = "touchpad";
+	sony_tpad->attr.attr.mode = S_IRUGO | S_IWUSR;
+	sony_tpad->attr.show = sony_nc_touchpad_show;
+	sony_tpad->attr.store = sony_nc_touchpad_store;
+
+	if (device_create_file(&pd->dev, &sony_tpad->attr)) {
+		kfree(sony_tpad);
+		sony_tpad = NULL;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sony_nc_touchpad_cleanup(struct platform_device *pd)
+{
+	if (sony_tpad) {
+		device_remove_file(&pd->dev, &sony_tpad->attr);
+		kfree(sony_tpad);
+		sony_tpad = NULL;
+	}
+
+	return 0;
+}
+
+#define SONY_FAN_HANDLE 0x0149
+#define FAN_SPEEDS_NUM	4	/* leave some more room */
+#define FAN_ATTRS_NUM	3
+static struct sony_fan_device {
+	unsigned int speeds_num;
+	unsigned int speeds[4];
+	struct device_attribute	attrs[3];
+} *sony_fan;
+
+static ssize_t sony_nc_fan_control_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned int result;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value)
+		|| value > sony_fan->speeds_num)
+		return -EINVAL;
+
+	if (sony_call_snc_handle(SONY_FAN_HANDLE,
+				(value << 0x10) | 0x0200, &result))
+		return -EIO;
+
+	return count;
+}
+
+static ssize_t sony_nc_fan_control_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(SONY_FAN_HANDLE, 0x0100, &result))
+		return -EINVAL;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", result & 0xff);
+	return count;
+}
+
+static ssize_t sony_nc_fan_profiles_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int i;
+
+	for (i = 0; i < sony_fan->speeds_num; i++)
+		count += snprintf(buffer + count, PAGE_SIZE - count,
+				"%.4u ", sony_fan->speeds[i] * 100);
+
+	count += snprintf(buffer + count, PAGE_SIZE - count, "\n");
+
+	return count;
+}
+
+static ssize_t sony_nc_fan_speed_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(SONY_FAN_HANDLE, 0x0300, &result))
+		return -EINVAL;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n",
+				(result & 0xff) * 100);
+	return count;
+}
+
+static int sony_nc_fan_setup(struct platform_device *pd)
+{
+	int ret;
+	unsigned int i, found;
+	u8 list[FAN_SPEEDS_NUM * 2] = { 0 };
+
+	sony_fan = kzalloc(sizeof(struct sony_fan_device), GFP_KERNEL);
+	if (!sony_fan)
+		return -ENOMEM;
+
+	ret = sony_call_snc_handle_buffer(SONY_FAN_HANDLE, 0x0000,
+					list, FAN_SPEEDS_NUM * 2);
+	if (ret < 0)
+		pr_info("unable to retrieve fan profiles table\n");
+
+	for (i = 0, found = 0;
+		list[i] != 0 && found < FAN_SPEEDS_NUM; i += 2, found++) {
+
+		sony_fan->speeds[found] = list[i+1];
+	}
+	sony_fan->speeds_num = found;
+
+	sysfs_attr_init(&sony_fan->attrs[0].attr);
+	sony_fan->attrs[0].attr.name = "fan_speed";
+	sony_fan->attrs[0].attr.mode = S_IRUGO;
+	sony_fan->attrs[0].show = sony_nc_fan_speed_show;
+
+	sysfs_attr_init(&sony_fan->attrs[1].attr);
+	sony_fan->attrs[1].attr.name = "fan_profiles";
+	sony_fan->attrs[1].attr.mode = S_IRUGO;
+	sony_fan->attrs[1].show = sony_nc_fan_profiles_show;
+
+	sysfs_attr_init(&sony_fan->attrs[2].attr);
+	sony_fan->attrs[2].attr.name = "fan_control";
+	sony_fan->attrs[2].attr.mode = S_IRUGO | S_IWUSR;
+	sony_fan->attrs[2].show = sony_nc_fan_control_show;
+	sony_fan->attrs[2].store = sony_nc_fan_control_store;
+
+	for (i = 0; i < FAN_ATTRS_NUM; i++) {
+		if (device_create_file(&pd->dev, &sony_fan->attrs[i]))
+			goto attrserror;
+	}
+
+	return 0;
+
+attrserror:
+	for (; i > 0; i--)
+		device_remove_file(&pd->dev, &sony_fan->attrs[i]);
+
+	kfree(sony_fan);
+	sony_fan = NULL;
+
+	return -1;
+}
+
+static int sony_nc_fan_cleanup(struct platform_device *pd)
+{
+	if (sony_fan) {
+		int i;
+
+		for (i = 0; i < FAN_ATTRS_NUM; i++)
+			device_remove_file(&pd->dev, &sony_fan->attrs[i]);
+
+		kfree(sony_fan);
+		sony_fan = NULL;
+	}
+
+	return 0;
+}
+
+static struct sony_odd_device {
+	unsigned int vendor_id;
+	unsigned int model_id;
+	struct device_attribute status_attr;
+} *sony_odd;
+
+#if 0
+static int sony_nc_odd_remove(void)
+{
+	/*
+	   0 - change the link state first?
+	   1 - scsi lookup searching for the optical device (scsi_device *)
+	   2 - call int scsi_remove_device(struct scsi_device *sdev)
+	*/
+
+	struct scsi_device *sdev;
+	struct Scsi_Host *shost;
+	int error = -ENXIO;
+
+	shost = scsi_host_lookup(host);
+	if (!shost)
+		return error;
+
+	sdev = scsi_device_lookup(shost, channel, id, lun);
+	if (sdev) {
+		scsi_remove_device(sdev);
+		scsi_device_put(sdev);
+		error = 0;
+	}
+
+	scsi_host_put(shost);
+
+	return 0;
+}
+#endif
+
+static ssize_t sony_nc_odd_status_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buffer, size_t count)
+{
+	unsigned int result;
+	unsigned long value;
+
+	if (count > 31)
+		return -EINVAL;
+	if (strict_strtoul(buffer, 10, &value) || value > 1)
+		return -EINVAL;
+
+#if 0
+	if (off)
+		sony_nc_odd_remove();
+
+		/* and goes on, otherwise leave */
+#endif
+
+	/* 0x200 turn on (sysfs: 1), 0x300 turn off (sysfs: 0) */
+	value = (!value << 0x08) + 0x200;
+
+	/* the MSB have to be high */
+	if (sony_call_snc_handle(0x126, (1 << 0x10) | value, &result))
+		return -EIO;
+
+#if 0
+	if (on)
+		/* force a bus scan? */
+#endif
+
+	return count;
+}
+
+static ssize_t sony_nc_odd_status_show(struct device *dev,
+		struct device_attribute *attr, char *buffer)
+{
+	ssize_t count = 0;
+	unsigned int result;
+
+	if (sony_call_snc_handle(0x126, 0x100, &result))
+		return -EINVAL;
+
+	count = snprintf(buffer, PAGE_SIZE, "%d\n", result & 0x01);
+	return count;
+}
+
+static int sony_nc_odd_setup(struct platform_device *pd)
+{
+#define ODD_TAB_SIZE 32
+	u8 list[ODD_TAB_SIZE] = { 0 };
+	int ret = 0;
+	int found = 0;
+	int i = 0;
+	unsigned int vendor = 0;
+	unsigned int model = 0;
+	u16 word = 0;
+
+	ret = sony_call_snc_handle_buffer(0x126, 0x0000, list, ODD_TAB_SIZE);
+	if (ret < 0) {
+		pr_info("unable to retrieve the odd table\n");
+		return -EIO;
+	}
+
+	/* parse the table looking for optical devices */
+	do {
+		word = (list[i+1] << 8) | list[i];
+
+		if (word == 1) { /* 1 DWord device data following */
+			vendor = (list[i+3] << 8) | list[i+2];
+			model = (list[i+5] << 8) | list[i+4];
+			found++;
+			i += 6;
+		} else {
+			i += 2;
+		}
+	} while (word != 0xff00);
+
+	if (found)
+		dprintk("one optical device found, connected to: %x:%x\n",
+				vendor, model);
+	else
+		return 0;
+
+	sony_odd = kzalloc(sizeof(*sony_odd), GFP_KERNEL);
+	if (!sony_odd)
+		return -ENOMEM;
+
+	sony_odd->vendor_id = vendor;
+	sony_odd->model_id = model;
+
+	sysfs_attr_init(&sony_odd->status_attr.attr);
+	sony_odd->status_attr.attr.name = "odd_power";
+	sony_odd->status_attr.attr.mode = S_IRUGO | S_IWUSR;
+	sony_odd->status_attr.show = sony_nc_odd_status_show;
+	sony_odd->status_attr.store = sony_nc_odd_status_store;
+
+	if (device_create_file(&pd->dev, &sony_odd->status_attr)) {
+		kfree(sony_odd);
+		sony_odd = NULL;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int sony_nc_odd_cleanup(struct platform_device *pd)
+{
+	if (sony_odd) {
+		device_remove_file(&pd->dev, &sony_odd->status_attr);
+		kfree(sony_odd);
+		sony_odd = NULL;
+	}
+
+	return 0;
+}
+
+/*
+ * Backlight device
+ */
+static struct backlight_device *sony_backlight_device;
+
+static int sony_backlight_update_status(struct backlight_device *bd)
+{
+	return acpi_callsetfunc(sony_nc_acpi_handle, "SBRT",
+				bd->props.brightness + 1, NULL);
+}
+
+static int sony_backlight_get_brightness(struct backlight_device *bd)
+{
+	unsigned int value;
+
+	if (acpi_callgetfunc(sony_nc_acpi_handle, "GBRT", &value))
+		return 0;
+	/* brightness levels are 1-based, while backlight ones are 0-based */
+	return value - 1;
+}
+
+static const struct backlight_ops sony_backlight_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.update_status = sony_backlight_update_status,
+	.get_brightness = sony_backlight_get_brightness,
+};
+static const struct backlight_ops sony_als_backlight_ops = {
+	.options = BL_CORE_SUSPENDRESUME,
+	.update_status = sony_nc_als_update_status,
+	.get_brightness = sony_nc_als_get_brightness,
+};
+
+static void sony_nc_backlight_setup(void)
+{
+	acpi_handle unused;
+	int max_brightness = 0;
+	const struct backlight_ops *ops = NULL;
+	struct backlight_properties props;
+
+	/* do not use SNC GBRT/SBRT controls along with the ALS */
+	if (sony_als) {
+		/* ALS based backlight device */
+		ops = &sony_als_backlight_ops;
+		max_brightness = sony_als->levels_num - 1;
+	} else if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "GBRT",
+						&unused))) {
+		ops = &sony_backlight_ops;
+		max_brightness = SONY_MAX_BRIGHTNESS - 1;
+	} else {
+		return;
+	}
+
+	memset(&props, 0, sizeof(struct backlight_properties));
+	props.type = BACKLIGHT_PLATFORM;
+	props.max_brightness = max_brightness;
+	sony_backlight_device = backlight_device_register("sony", NULL, NULL,
+								ops, &props);
+
+	if (IS_ERR(sony_backlight_device)) {
+		pr_warn("unable to register backlight device\n");
+		sony_backlight_device = NULL;
+	} else {
+		sony_backlight_device->props.brightness =
+			ops->get_brightness(sony_backlight_device);
+	}
+}
+
+static void sony_nc_backlight_cleanup(void)
+{
+	if (sony_backlight_device)
+		backlight_device_unregister(sony_backlight_device);
+}
+
+static void sony_nc_tests_resume(void)
+{
+	return;
+}
+
+/* place here some unknown handles, we might want to see some output */
+static void sony_nc_tests_setup(void)
+{
+	int ret;
+	unsigned int result;
+
+	result = 0;
+	ret = sony_call_snc_handle(0x114, 0x000, &result);
+	if (!ret)
+		pr_info("handle 0x114 returned: %x\n", result & 0xff);
+
+	result = 0;
+	ret = sony_call_snc_handle(0x139, 0x0000, &result);
+	if (!ret)
+		pr_info("handle 0x139+00 returned: %x\n", result & 0xffff);
+
+	result = 0;
+	ret = sony_call_snc_handle(0x139, 0x0100, &result);
+	if (!ret)
+		pr_info("handle 0x139+01 returned: %x\n", result & 0xffff);
+
+	return;
+}
+
+static void sony_nc_snc_setup_handles(struct platform_device *pd)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(handles->cap); i++) {
+		int ret = 0;
+		int unsigned handle = handles->cap[i];
+
+		if (!handle)
+			continue;
+
+		dprintk("looking at handle 0x%.4x\n", handle);
+
+		switch (handle) {
+		case 0x0100:
+		case 0x0127:
+		case 0x0101:
+		case 0x0102:
+			ret = sony_nc_function_setup(handle);
+			break;
+		case 0x0105:
+		case 0x0148: /* same as 0x0105 + Fn-F1 combo */
+			ret = sony_nc_touchpad_setup(pd, handle);
+			break;
+		case 0x0115:
+		case 0x0136:
+		case 0x013f:
+			ret = sony_nc_battery_care_setup(pd, handle);
+			break;
+		case 0x0119:
+			ret = sony_nc_lid_resume_setup(pd);
+			break;
+		case 0x0122:
+			ret = sony_nc_thermal_setup(pd);
+			break;
+		case 0x0126:
+			ret = sony_nc_odd_setup(pd);
+			break;
+		case 0x0137:
+		case 0x0143:
+			ret = sony_nc_kbd_backlight_setup(pd, handle);
+		case 0x012f: /* no keyboard backlight */
+			ret = sony_nc_als_setup(pd, handle);
+			break;
+		case 0x0131:
+			ret = sony_nc_highspeed_charging_setup(pd);
+			break;
+		case 0x0134:
+		case 0x0147:
+			ret = sony_nc_gsensor_setup(pd, handle);
+			break;
+		case 0x0149:
+			ret = sony_nc_fan_setup(pd);
+			break;
+		case 0x0124:
+		case 0x0135:
+			ret = sony_nc_rfkill_setup(sony_nc_acpi_device, handle);
+			break;
+		default:
+			continue;
+		}
+
+		if (ret < 0) {
+			pr_warn("handle 0x%.4x setup failed (ret: %i)",
+								handle, ret);
+		} else {
+			dprintk("handle 0x%.4x setup completed\n", handle);
+		}
 	}
 
-out_no_enum:
-	kfree(buffer.pointer);
-	return;
+	if (debug)
+		sony_nc_tests_setup();
 }
 
-/* Keyboard backlight feature */
-#define KBDBL_HANDLER	0x137
-#define KBDBL_PRESENT	0xB00
-#define	SET_MODE	0xC00
-#define SET_STATE	0xD00
-#define SET_TIMEOUT	0xE00
-
-struct kbd_backlight {
-	int mode;
-	int timeout;
-	struct device_attribute mode_attr;
-	struct device_attribute timeout_attr;
-};
-
-static struct kbd_backlight *kbdbl_handle;
-
-static ssize_t __sony_nc_kbd_backlight_mode_set(u8 value)
+static void sony_nc_snc_cleanup_handles(struct platform_device *pd)
 {
-	int result;
+	unsigned int i;
 
-	if (value > 1)
-		return -EINVAL;
+	for (i = 0; i < ARRAY_SIZE(handles->cap); i++) {
 
-	if (sony_call_snc_handle(KBDBL_HANDLER,
-				(value << 0x10) | SET_MODE, &result))
-		return -EIO;
+		int unsigned handle = handles->cap[i];
 
-	/* Try to turn the light on/off immediately */
-	sony_call_snc_handle(KBDBL_HANDLER, (value << 0x10) | SET_STATE,
-			&result);
+		if (!handle)
+			continue;
 
-	kbdbl_handle->mode = value;
+		dprintk("looking at handle 0x%.4x\n", handle);
 
-	return 0;
+		switch (handle) {
+		case 0x0105:
+		case 0x0148:
+			sony_nc_touchpad_cleanup(pd);
+			break;
+		case 0x0115:
+		case 0x0136:
+		case 0x013f:
+			sony_nc_battery_care_cleanup(pd);
+			break;
+		case 0x0119:
+			sony_nc_lid_resume_cleanup(pd);
+			break;
+		case 0x0122:
+			sony_nc_thermal_cleanup(pd);
+			break;
+		case 0x0126:
+			sony_nc_odd_cleanup(pd);
+			break;
+		case 0x0137:
+		case 0x0143:
+			sony_nc_kbd_backlight_cleanup(pd);
+		case 0x012f:
+			sony_nc_als_cleanup(pd);
+			break;
+		case 0x0131:
+			sony_nc_highspeed_charging_cleanup(pd);
+			break;
+		case 0x0134:
+		case 0x0147:
+			sony_nc_gsensor_cleanup(pd);
+			break;
+		case 0x0149:
+			sony_nc_fan_cleanup(pd);
+			break;
+		case 0x0124:
+		case 0x0135:
+			sony_nc_rfkill_cleanup();
+			break;
+		default:
+			continue;
+		}
+
+		dprintk("handle 0x%.4x deconfigured\n", handle);
+	}
 }
 
-static ssize_t sony_nc_kbd_backlight_mode_store(struct device *dev,
-		struct device_attribute *attr,
-		const char *buffer, size_t count)
+static int sony_nc_snc_setup(struct platform_device *pd)
 {
-	int ret = 0;
-	unsigned long value;
-
-	if (count > 31)
-		return -EINVAL;
-
-	if (strict_strtoul(buffer, 10, &value))
-		return -EINVAL;
+	unsigned int i, string[4], bitmask, result;
 
-	ret = __sony_nc_kbd_backlight_mode_set(value);
-	if (ret < 0)
-		return ret;
+	for (i = 0; i < 4; i++) {
+		if (acpi_callsetfunc(sony_nc_acpi_handle,
+				"SN00", i, &string[i]))
+			return -EIO;
+	}
+	if (strncmp("SncSupported", (char *) string, 0x10)) {
+		pr_info("SNC device present but not supported by hardware");
+		return -1;
+	}
 
-	return count;
-}
+	if (!acpi_callsetfunc(sony_nc_acpi_handle, "SN00", 0x04, &result)) {
+		unsigned int model, i;
+		for (model = 0, i = 0; i < 4; i++)
+			model |= ((result >> (i * 8)) & 0xff) << ((3 - i) * 8);
+		pr_info("found Vaio model ID: %u\n", model);
+	}
 
-static ssize_t sony_nc_kbd_backlight_mode_show(struct device *dev,
-		struct device_attribute *attr, char *buffer)
-{
-	ssize_t count = 0;
-	count = snprintf(buffer, PAGE_SIZE, "%d\n", kbdbl_handle->mode);
-	return count;
-}
+	/* retrieve the implemented offsets mask */
+	if (acpi_callsetfunc(sony_nc_acpi_handle, "SN00", 0x10, &bitmask))
+		return -EIO;
 
-static int __sony_nc_kbd_backlight_timeout_set(u8 value)
-{
-	int result;
+	/* retrieve the available handles, otherwise return */
+	if (sony_nc_handles_setup(pd))
+		return -2;
 
-	if (value > 3)
-		return -EINVAL;
+	/* setup found handles here */
+	sony_nc_snc_setup_handles(pd);
 
-	if (sony_call_snc_handle(KBDBL_HANDLER,
-				(value << 0x10) | SET_TIMEOUT, &result))
+	/* Enable all events for the found handles, otherwise return */
+	if (acpi_callsetfunc(sony_nc_acpi_handle, "SN02", bitmask, &result))
 		return -EIO;
 
-	kbdbl_handle->timeout = value;
+	/* check for SN05 presence? */
 
 	return 0;
 }
 
-static ssize_t sony_nc_kbd_backlight_timeout_store(struct device *dev,
-		struct device_attribute *attr,
-		const char *buffer, size_t count)
+static int sony_nc_snc_cleanup(struct platform_device *pd)
 {
-	int ret = 0;
-	unsigned long value;
+	unsigned int result, bitmask;
 
-	if (count > 31)
-		return -EINVAL;
+	/* retrieve the event enabled handles */
+	acpi_callgetfunc(sony_nc_acpi_handle, "SN01", &bitmask);
 
-	if (strict_strtoul(buffer, 10, &value))
-		return -EINVAL;
+	/* disable the event generation	for every handle */
+	acpi_callsetfunc(sony_nc_acpi_handle, "SN03", bitmask, &result);
 
-	ret = __sony_nc_kbd_backlight_timeout_set(value);
-	if (ret < 0)
-		return ret;
+	/* cleanup handles here */
+	sony_nc_snc_cleanup_handles(pd);
 
-	return count;
-}
+	sony_nc_handles_cleanup(pd);
 
-static ssize_t sony_nc_kbd_backlight_timeout_show(struct device *dev,
-		struct device_attribute *attr, char *buffer)
-{
-	ssize_t count = 0;
-	count = snprintf(buffer, PAGE_SIZE, "%d\n", kbdbl_handle->timeout);
-	return count;
+	return 0;
 }
 
-static int sony_nc_kbd_backlight_setup(struct platform_device *pd)
+static int sony_nc_snc_resume(void)
 {
-	int result;
+	unsigned int i, result, bitmask;
 
-	if (sony_call_snc_handle(KBDBL_HANDLER, KBDBL_PRESENT, &result))
-		return 0;
-	if (!(result & 0x02))
-		return 0;
+	/* retrieve the implemented offsets mask */
+	if (acpi_callsetfunc(sony_nc_acpi_handle, "SN00", 0x10, &bitmask))
+		return -EIO;
 
-	kbdbl_handle = kzalloc(sizeof(*kbdbl_handle), GFP_KERNEL);
-	if (!kbdbl_handle)
-		return -ENOMEM;
+	/* Enable all events, otherwise return */
+	if (acpi_callsetfunc(sony_nc_acpi_handle, "SN02", bitmask, &result))
+		return -EIO;
+
+	for (i = 0; i < ARRAY_SIZE(handles->cap); i++) {
+		int unsigned handle = handles->cap[i];
 
-	sysfs_attr_init(&kbdbl_handle->mode_attr.attr);
-	kbdbl_handle->mode_attr.attr.name = "kbd_backlight";
-	kbdbl_handle->mode_attr.attr.mode = S_IRUGO | S_IWUSR;
-	kbdbl_handle->mode_attr.show = sony_nc_kbd_backlight_mode_show;
-	kbdbl_handle->mode_attr.store = sony_nc_kbd_backlight_mode_store;
-
-	sysfs_attr_init(&kbdbl_handle->timeout_attr.attr);
-	kbdbl_handle->timeout_attr.attr.name = "kbd_backlight_timeout";
-	kbdbl_handle->timeout_attr.attr.mode = S_IRUGO | S_IWUSR;
-	kbdbl_handle->timeout_attr.show = sony_nc_kbd_backlight_timeout_show;
-	kbdbl_handle->timeout_attr.store = sony_nc_kbd_backlight_timeout_store;
+		if (!handle)
+			continue;
 
-	if (device_create_file(&pd->dev, &kbdbl_handle->mode_attr))
-		goto outkzalloc;
+		dprintk("looking at handle 0x%.4x\n", handle);
 
-	if (device_create_file(&pd->dev, &kbdbl_handle->timeout_attr))
-		goto outmode;
+		switch (handle) {
+		case 0x0100:
+		case 0x0127:
+		case 0x0101:
+		case 0x0102:
+			sony_nc_function_setup(handle);
+			break;
+		case 0x0122:
+			sony_nc_thermal_resume();
+			break;
+		case 0x0124:
+		case 0x0135:
+			/* re-read rfkill state */
+			sony_nc_rfkill_update();
+			break;
+		case 0x0137: /* kbd + als */
+		case 0x0143:
+			sony_nc_kbd_backlight_resume();
+		case 0x012f: /* als only */
+			sony_nc_als_resume();
+			break;
+		default:
+			continue;
+		}
 
-	__sony_nc_kbd_backlight_mode_set(kbd_backlight);
-	__sony_nc_kbd_backlight_timeout_set(kbd_backlight_timeout);
+		dprintk("handle 0x%.4x updated\n", handle);
+	}
 
-	return 0;
+	if (debug)
+		sony_nc_tests_resume();
 
-outmode:
-	device_remove_file(&pd->dev, &kbdbl_handle->mode_attr);
-outkzalloc:
-	kfree(kbdbl_handle);
-	kbdbl_handle = NULL;
-	return -1;
+	return 0;
 }
 
-static int sony_nc_kbd_backlight_cleanup(struct platform_device *pd)
+/*
+ * ACPI callbacks
+ */
+static acpi_status sony_walk_callback(acpi_handle handle, u32 level,
+				      void *context, void **return_value)
 {
-	if (kbdbl_handle) {
-		int result;
-
-		device_remove_file(&pd->dev, &kbdbl_handle->mode_attr);
-		device_remove_file(&pd->dev, &kbdbl_handle->timeout_attr);
+	struct acpi_device_info *info;
 
-		/* restore the default hw behaviour */
-		sony_call_snc_handle(KBDBL_HANDLER, 0x1000 | SET_MODE, &result);
-		sony_call_snc_handle(KBDBL_HANDLER, SET_TIMEOUT, &result);
+	if (ACPI_SUCCESS(acpi_get_object_info(handle, &info))) {
+		pr_warn("method: name: %4.4s, args %X\n",
+			(char *)&info->name, info->param_count);
 
-		kfree(kbdbl_handle);
+		kfree(info);
 	}
-	return 0;
+
+	return AE_OK;
 }
 
-static void sony_nc_kbd_backlight_resume(void)
+#define EV_HOTKEYS	1
+#define EV_RFKILL	2
+#define EV_ALS		3
+#define EV_GSENSOR	4
+#define	EV_HGFX		5
+static void sony_nc_notify(struct acpi_device *device, u32 event)
 {
-	int ignore = 0;
+	u8 ev = 0;
+	int value = 0;
+	char *env[2] = { NULL };
 
-	if (!kbdbl_handle)
-		return;
+	dprintk("sony_nc_notify, event: 0x%.2x\n", event);
 
-	if (kbdbl_handle->mode == 0)
-		sony_call_snc_handle(KBDBL_HANDLER, SET_MODE, &ignore);
+	/* handles related events */
+	if (event >= 0x90) {
+		unsigned int result = 0, handle = 0;
+
+		/* the event should corrispond to the offset of the method */
+		unsigned int offset = event - 0x90;
+
+		handle = handles->cap[offset];
+		switch (handle) {
+		/* list of handles known for generating events */
+		case 0x0100:
+		case 0x0127:
+			/* hotkey event, a key has been pressed, retrieve it */
+			value = sony_nc_hotkeys_decode(handle);
+			if (value > 0) /* known event */
+				sony_laptop_report_input_event(value);
+			else /* restore the original event */
+			    value = event;
 
-	if (kbdbl_handle->timeout != 0)
-		sony_call_snc_handle(KBDBL_HANDLER,
-				(kbdbl_handle->timeout << 0x10) | SET_TIMEOUT,
-				&ignore);
-}
+			ev = EV_HOTKEYS;
+			break;
 
-static void sony_nc_backlight_ng_read_limits(int handle,
-		struct sony_backlight_props *props)
-{
-	int offset;
-	acpi_status status;
-	u8 brlvl, i;
-	u8 min = 0xff, max = 0x00;
-	struct acpi_object_list params;
-	union acpi_object in_obj;
-	union acpi_object *lvl_enum;
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+		case 0x0143:
+			sony_call_snc_handle(handle, 0x2000, &result);
+			/* event reasons are reverted */
+			value = (result & 0x03) == 1 ? 2 : 1;
+			dprintk("sony_nc_notify, ALS event received (reason:"
+				       " %s change)\n", value == 1 ? "light" :
+				       "backlight");
 
-	props->handle = handle;
-	props->offset = 0;
-	props->maxlvl = 0xff;
+			env[0] = (value == 1) ? "ALS=1" : "ALS=2";
+			kobject_uevent_env(&device->dev.kobj, KOBJ_CHANGE, env);
 
-	offset = sony_find_snc_handle(handle);
-	if (offset < 0)
-		return;
+			ev = EV_ALS;
+			break;
 
-	/* try to read the boundaries from ACPI tables, if we fail the above
-	 * defaults should be reasonable
-	 */
-	params.count = 1;
-	params.pointer = &in_obj;
-	in_obj.type = ACPI_TYPE_INTEGER;
-	in_obj.integer.value = offset;
-	status = acpi_evaluate_object(sony_nc_acpi_handle, "SN06", &params,
-			&buffer);
-	if (ACPI_FAILURE(status))
-		return;
+		case 0x012f:
+		case 0x0137:
+			sony_call_snc_handle(handle, 0x0800, &result);
+			value = result & 0x03;
+			dprintk("sony_nc_notify, ALS event received (reason:"
+					" %s change)\n", value == 1 ? "light" :
+					"backlight");
+			if (value == 1) /* lighting change reason */
+				sony_nc_als_event_handler();
 
-	lvl_enum = (union acpi_object *) buffer.pointer;
-	if (!lvl_enum) {
-		pr_err("No SN06 return object.");
-		return;
-	}
-	if (lvl_enum->type != ACPI_TYPE_BUFFER) {
-		pr_err("Invalid SN06 return object 0x%.2x\n",
-		       lvl_enum->type);
-		goto out_invalid;
-	}
+			env[0] = (value == 1) ? "ALS=1" : "ALS=2";
+			kobject_uevent_env(&device->dev.kobj, KOBJ_CHANGE, env);
 
-	/* the buffer lists brightness levels available, brightness levels are
-	 * from 0 to 8 in the array, other values are used by ALS control.
-	 */
-	for (i = 0; i < 9 && i < lvl_enum->buffer.length; i++) {
+			ev = EV_ALS;
+			break;
 
-		brlvl = *(lvl_enum->buffer.pointer + i);
-		dprintk("Brightness level: %d\n", brlvl);
+		case 0x0124:
+		case 0x0135:
+			sony_call_snc_handle(handle, 0x0100, &result);
+			result &= 0x03;
+			dprintk("sony_nc_notify, RFKILL event received "
+					"(reason: %s)\n", result == 1 ?
+					"switch state changed" : "battery");
+
+			if (result == 1) { /* hw swtich event */
+				sony_nc_rfkill_update();
+				value = sony_nc_get_rfkill_hwblock();
+			} else if (result == 2) { /* battery event */
+				/*  we might need to change the WWAN rfkill
+				    state when the battery state changes
+				 */
+				sony_nc_rfkill_update_wwan();
+				return;
+			}
 
-		if (!brlvl)
+			ev = EV_RFKILL;
 			break;
 
-		if (brlvl > max)
-			max = brlvl;
-		if (brlvl < min)
-			min = brlvl;
-	}
-	props->offset = min;
-	props->maxlvl = max;
-	dprintk("Brightness levels: min=%d max=%d\n", props->offset,
-			props->maxlvl);
+		case 0x0134:
+		case 0x0147:
+			ev = 4;
+			value = EV_GSENSOR;
+			/* hdd protection event, notify userspace */
 
-out_invalid:
-	kfree(buffer.pointer);
-	return;
-}
+			env[0] = "HDD_SHOCK=1";
+			kobject_uevent_env(&device->dev.kobj, KOBJ_CHANGE, env);
 
-static void sony_nc_backlight_setup(void)
-{
-	acpi_handle unused;
-	int max_brightness = 0;
-	const struct backlight_ops *ops = NULL;
-	struct backlight_properties props;
+			break;
 
-	if (sony_find_snc_handle(0x12f) != -1) {
-		ops = &sony_backlight_ng_ops;
-		sony_nc_backlight_ng_read_limits(0x12f, &sony_bl_props);
-		max_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;
-
-	} else if (sony_find_snc_handle(0x137) != -1) {
-		ops = &sony_backlight_ng_ops;
-		sony_nc_backlight_ng_read_limits(0x137, &sony_bl_props);
-		max_brightness = sony_bl_props.maxlvl - sony_bl_props.offset;
+		case 0x0128:
+		case 0x0146:
+			/* Hybrid GFX switching, 1 */
+			sony_call_snc_handle(handle, 0x0000, &result);
+			dprintk("sony_nc_notify, Hybrid GFX event received "
+					"(reason: %s)\n", (result & 0x01) ?
+					"switch position change" : "unknown");
+
+			/* verify the switch state
+			   (1: discrete GFX, 0: integrated GFX)*/
+			result = 0;
+			sony_call_snc_handle(handle, 0x0100, &result);
 
-	} else if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "GBRT",
-						&unused))) {
-		ops = &sony_backlight_ops;
-		max_brightness = SONY_MAX_BRIGHTNESS - 1;
+			/* sony_laptop_report_input_event(); */
 
-	} else
-		return;
+			ev = EV_HGFX;
+			value = result & 0xff;
+			break;
 
-	memset(&props, 0, sizeof(struct backlight_properties));
-	props.type = BACKLIGHT_PLATFORM;
-	props.max_brightness = max_brightness;
-	sony_bl_props.dev = backlight_device_register("sony", NULL,
-						      &sony_bl_props,
-						      ops, &props);
+		default:
+			value = event;
+			dprintk("Unknowk event for handle: 0x%x\n", handle);
+			break;
+		}
 
-	if (IS_ERR(sony_bl_props.dev)) {
-		pr_warn("unable to register backlight device\n");
-		sony_bl_props.dev = NULL;
-	} else
-		sony_bl_props.dev->props.brightness =
-			ops->get_brightness(sony_bl_props.dev);
-}
+		/* clear the event (and the event reason when present) */
+		acpi_callsetfunc(sony_nc_acpi_handle, "SN05", 1 << offset,
+				&result);
+	} else {
+		ev = 1;
+		sony_laptop_report_input_event(event);
+	}
 
-static void sony_nc_backlight_cleanup(void)
-{
-	if (sony_bl_props.dev)
-		backlight_device_unregister(sony_bl_props.dev);
+	acpi_bus_generate_proc_event(device, ev, value);
+	acpi_bus_generate_netlink_event(device->pnp.device_class,
+					dev_name(&device->dev), ev, value);
 }
 
 static int sony_nc_add(struct acpi_device *device)
@@ -1688,7 +4348,8 @@ static int sony_nc_add(struct acpi_devic
 
 	/* read device status */
 	result = acpi_bus_get_status(device);
-	/* bail IFF the above call was successful and the device is not present */
+	/* bail IFF the above call was successful
+	   and the device is not present */
 	if (!result && !device->status.present) {
 		dprintk("Device not present\n");
 		result = -ENODEV;
@@ -1719,25 +4380,21 @@ static int sony_nc_add(struct acpi_devic
 	if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "SN00",
 					 &handle))) {
 		dprintk("Doing SNC setup\n");
-		result = sony_nc_handles_setup(sony_pf_device);
-		if (result)
-			goto outpresent;
-		result = sony_nc_kbd_backlight_setup(sony_pf_device);
-		if (result)
+
+		if (sony_nc_snc_setup(sony_pf_device))
 			goto outsnc;
-		sony_nc_function_setup(device);
-		sony_nc_rfkill_setup(device);
 	}
 
 	/* setup input devices and helper fifo */
 	result = sony_laptop_setup_input(device);
 	if (result) {
 		pr_err("Unable to create input devices\n");
-		goto outkbdbacklight;
+		goto outsnc;
 	}
 
 	if (acpi_video_backlight_support()) {
-		pr_info("brightness ignored, must be controlled by ACPI video driver\n");
+		pr_info("brightness ignored, must be "
+			"controlled by ACPI video driver\n");
 	} else {
 		sony_nc_backlight_setup();
 	}
@@ -1783,25 +4440,21 @@ static int sony_nc_add(struct acpi_devic
 
 	return 0;
 
-      out_sysfs:
-	for (item = sony_nc_values; item->name; ++item) {
+out_sysfs:
+	for (item = sony_nc_values; item->name; ++item)
 		device_remove_file(&sony_pf_device->dev, &item->devattr);
-	}
+
 	sony_nc_backlight_cleanup();
 
 	sony_laptop_remove_input();
 
-      outkbdbacklight:
-	sony_nc_kbd_backlight_cleanup(sony_pf_device);
-
-      outsnc:
-	sony_nc_handles_cleanup(sony_pf_device);
+outsnc:
+	sony_nc_snc_cleanup(sony_pf_device);
 
-      outpresent:
+outpresent:
 	sony_pf_remove();
 
-      outwalk:
-	sony_nc_rfkill_cleanup();
+outwalk:
 	return result;
 }
 
@@ -1813,20 +4466,56 @@ static int sony_nc_remove(struct acpi_de
 
 	sony_nc_acpi_device = NULL;
 
-	for (item = sony_nc_values; item->name; ++item) {
+	for (item = sony_nc_values; item->name; ++item)
 		device_remove_file(&sony_pf_device->dev, &item->devattr);
-	}
 
-	sony_nc_kbd_backlight_cleanup(sony_pf_device);
-	sony_nc_handles_cleanup(sony_pf_device);
+	sony_nc_snc_cleanup(sony_pf_device);
 	sony_pf_remove();
 	sony_laptop_remove_input();
-	sony_nc_rfkill_cleanup();
 	dprintk(SONY_NC_DRIVER_NAME " removed.\n");
 
 	return 0;
 }
 
+static int sony_nc_resume(struct acpi_device *device)
+{
+	struct sony_nc_value *item;
+	acpi_handle handle;
+
+	for (item = sony_nc_values; item->name; item++) {
+		int ret;
+
+		if (!item->valid)
+			continue;
+		ret = acpi_callsetfunc(sony_nc_acpi_handle, *item->acpiset,
+				       item->value, NULL);
+		if (ret < 0) {
+			pr_err("%s: %d\n", __func__, ret);
+			break;
+		}
+	}
+
+	if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "ECON",
+					 &handle))) {
+		if (acpi_callsetfunc(sony_nc_acpi_handle, "ECON", 1, NULL))
+			dprintk("ECON Method failed\n");
+	}
+
+	if (ACPI_SUCCESS(acpi_get_handle(sony_nc_acpi_handle, "SN00",
+					 &handle))) {
+		dprintk("Doing SNC setup\n");
+
+		sony_nc_snc_resume();
+	}
+
+	/* set the last requested brightness level */
+	if (sony_backlight_device &&
+		sony_backlight_ops.update_status(sony_backlight_device) < 0)
+		pr_warn("unable to restore brightness level\n");
+
+	return 0;
+}
+
 static const struct acpi_device_id sony_device_ids[] = {
 	{SONY_NC_HID, 0},
 	{SONY_PIC_HID, 0},
@@ -2165,11 +4854,14 @@ static u8 sony_pic_call3(u8 dev, u8 fn, 
 {
 	u8 v1;
 
-	wait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);
+	wait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,
+			ITERATIONS_LONG);
 	outb(dev, spic_dev.cur_ioport->io1.minimum + 4);
-	wait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);
+	wait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,
+			ITERATIONS_LONG);
 	outb(fn, spic_dev.cur_ioport->io1.minimum);
-	wait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2, ITERATIONS_LONG);
+	wait_on_command(inb_p(spic_dev.cur_ioport->io1.minimum + 4) & 2,
+			ITERATIONS_LONG);
 	outb(v, spic_dev.cur_ioport->io1.minimum);
 	v1 = inb_p(spic_dev.cur_ioport->io1.minimum);
 	dprintk("sony_pic_call3(0x%.2x - 0x%.2x - 0x%.2x): 0x%.4x\n",
@@ -2283,19 +4975,19 @@ out:
 /* the rest don't need a loop until not 0xff */
 #define SONYPI_CAMERA_AGC			6
 #define SONYPI_CAMERA_AGC_MASK			0x30
-#define SONYPI_CAMERA_SHUTTER_MASK 		0x7
+#define SONYPI_CAMERA_SHUTTER_MASK		0x7
 
 #define SONYPI_CAMERA_SHUTDOWN_REQUEST		7
 #define SONYPI_CAMERA_CONTROL			0x10
 
-#define SONYPI_CAMERA_STATUS 			7
-#define SONYPI_CAMERA_STATUS_READY 		0x2
+#define SONYPI_CAMERA_STATUS			7
+#define SONYPI_CAMERA_STATUS_READY		0x2
 #define SONYPI_CAMERA_STATUS_POSITION		0x4
 
-#define SONYPI_DIRECTION_BACKWARDS 		0x4
+#define SONYPI_DIRECTION_BACKWARDS		0x4
 
-#define SONYPI_CAMERA_REVISION 			8
-#define SONYPI_CAMERA_ROMVERSION 		9
+#define SONYPI_CAMERA_REVISION			8
+#define SONYPI_CAMERA_ROMVERSION		9
 
 static int __sony_pic_camera_ready(void)
 {
@@ -2379,28 +5071,28 @@ int sony_pic_camera_command(int command,
 			__sony_pic_camera_off();
 		break;
 	case SONY_PIC_COMMAND_SETCAMERABRIGHTNESS:
-		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_BRIGHTNESS, value),
-				ITERATIONS_SHORT);
+		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_BRIGHTNESS,
+				value),	ITERATIONS_SHORT);
 		break;
 	case SONY_PIC_COMMAND_SETCAMERACONTRAST:
-		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTRAST, value),
-				ITERATIONS_SHORT);
+		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_CONTRAST,
+				value),	ITERATIONS_SHORT);
 		break;
 	case SONY_PIC_COMMAND_SETCAMERAHUE:
 		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_HUE, value),
 				ITERATIONS_SHORT);
 		break;
 	case SONY_PIC_COMMAND_SETCAMERACOLOR:
-		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_COLOR, value),
-				ITERATIONS_SHORT);
+		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_COLOR,
+				value),	ITERATIONS_SHORT);
 		break;
 	case SONY_PIC_COMMAND_SETCAMERASHARPNESS:
-		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_SHARPNESS, value),
-				ITERATIONS_SHORT);
+		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_SHARPNESS,
+				value),	ITERATIONS_SHORT);
 		break;
 	case SONY_PIC_COMMAND_SETCAMERAPICTURE:
-		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE, value),
-				ITERATIONS_SHORT);
+		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_PICTURE,
+				value),	ITERATIONS_SHORT);
 		break;
 	case SONY_PIC_COMMAND_SETCAMERAAGC:
 		wait_on_command(sony_pic_call3(0x90, SONYPI_CAMERA_AGC, value),
@@ -2434,7 +5126,9 @@ static ssize_t sony_pic_wwanpower_store(
 	if (count > 31)
 		return -EINVAL;
 
-	value = simple_strtoul(buffer, NULL, 10);
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
+
 	mutex_lock(&spic_dev.lock);
 	__sony_pic_set_wwanpower(value);
 	mutex_unlock(&spic_dev.lock);
@@ -2471,7 +5165,9 @@ static ssize_t sony_pic_bluetoothpower_s
 	if (count > 31)
 		return -EINVAL;
 
-	value = simple_strtoul(buffer, NULL, 10);
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
+
 	mutex_lock(&spic_dev.lock);
 	__sony_pic_set_bluetoothpower(value);
 	mutex_unlock(&spic_dev.lock);
@@ -2510,7 +5206,9 @@ static ssize_t sony_pic_fanspeed_store(s
 	if (count > 31)
 		return -EINVAL;
 
-	value = simple_strtoul(buffer, NULL, 10);
+	if (strict_strtoul(buffer, 10, &value))
+		return -EINVAL;
+
 	if (sony_pic_set_fanspeed(value))
 		return -EIO;
 
@@ -2659,12 +5357,12 @@ static long sonypi_misc_ioctl(struct fil
 	void __user *argp = (void __user *)arg;
 	u8 val8;
 	u16 val16;
-	int value;
+	unsigned int value;
 
 	mutex_lock(&spic_dev.lock);
 	switch (cmd) {
 	case SONYPI_IOCGBRT:
-		if (sony_bl_props.dev == NULL) {
+		if (sony_backlight_device == NULL) {
 			ret = -EIO;
 			break;
 		}
@@ -2677,7 +5375,7 @@ static long sonypi_misc_ioctl(struct fil
 				ret = -EFAULT;
 		break;
 	case SONYPI_IOCSBRT:
-		if (sony_bl_props.dev == NULL) {
+		if (sony_backlight_device == NULL) {
 			ret = -EIO;
 			break;
 		}
@@ -2691,8 +5389,8 @@ static long sonypi_misc_ioctl(struct fil
 			break;
 		}
 		/* sync the backlight device status */
-		sony_bl_props.dev->props.brightness =
-		    sony_backlight_get_brightness(sony_bl_props.dev);
+		sony_backlight_device->props.brightness =
+		    sony_backlight_get_brightness(sony_backlight_device);
 		break;
 	case SONYPI_IOCGBAT1CAP:
 		if (ec_read16(SONYPI_BAT1_FULL, &val16)) {
@@ -2861,7 +5559,8 @@ sony_pic_read_possible_resource(struct a
 	case ACPI_RESOURCE_TYPE_START_DEPENDENT:
 		{
 			/* start IO enumeration */
-			struct sony_pic_ioport *ioport = kzalloc(sizeof(*ioport), GFP_KERNEL);
+			struct sony_pic_ioport *ioport =
+					kzalloc(sizeof(*ioport), GFP_KERNEL);
 			if (!ioport)
 				return AE_ERROR;
 
@@ -2909,7 +5608,8 @@ sony_pic_read_possible_resource(struct a
 		{
 			struct acpi_resource_io *io = &resource->data.io;
 			struct sony_pic_ioport *ioport =
-				list_first_entry(&dev->ioports, struct sony_pic_ioport, list);
+				list_first_entry(&dev->ioports,
+						struct sony_pic_ioport, list);
 			if (!io) {
 				dprintk("Blank IO resource\n");
 				return AE_OK;
@@ -2917,16 +5617,17 @@ sony_pic_read_possible_resource(struct a
 
 			if (!ioport->io1.minimum) {
 				memcpy(&ioport->io1, io, sizeof(*io));
-				dprintk("IO1 at 0x%.4x (0x%.2x)\n", ioport->io1.minimum,
+				dprintk("IO1 at 0x%.4x (0x%.2x)\n",
+						ioport->io1.minimum,
 						ioport->io1.address_length);
-			}
-			else if (!ioport->io2.minimum) {
+			} else if (!ioport->io2.minimum) {
 				memcpy(&ioport->io2, io, sizeof(*io));
-				dprintk("IO2 at 0x%.4x (0x%.2x)\n", ioport->io2.minimum,
+				dprintk("IO2 at 0x%.4x (0x%.2x)\n",
+						ioport->io2.minimum,
 						ioport->io2.address_length);
-			}
-			else {
-				pr_err("Unknown SPIC Type, more than 2 IO Ports\n");
+			} else {
+				pr_err("Unknown SPIC Type, "
+					"more than 2 IO Ports\n");
 				return AE_ERROR;
 			}
 			return AE_OK;
@@ -3249,24 +5950,26 @@ static int sony_pic_add(struct acpi_devi
 			/* Type 1 have 2 ioports */
 			if (io->io2.minimum) {
 				if (request_region(io->io2.minimum,
-						io->io2.address_length,
-						"Sony Programmable I/O Device")) {
-					dprintk("I/O port2: 0x%.4x (0x%.4x) + 0x%.2x\n",
-							io->io2.minimum, io->io2.maximum,
+					io->io2.address_length,
+					"Sony Programmable I/O Device")) {
+					dprintk("I/O port2: 0x%.4x (0x%.4x) "
+							"+ 0x%.2x\n",
+							io->io2.minimum,
+							io->io2.maximum,
 							io->io2.address_length);
 					spic_dev.cur_ioport = io;
 					break;
-				}
-				else {
+				} else {
 					dprintk("Unable to get I/O port2: "
-							"0x%.4x (0x%.4x) + 0x%.2x\n",
-							io->io2.minimum, io->io2.maximum,
+							"0x%.4x (0x%.4x) "
+							"+ 0x%.2x\n",
+							io->io2.minimum,
+							io->io2.maximum,
 							io->io2.address_length);
 					release_region(io->io1.minimum,
 							io->io1.address_length);
 				}
-			}
-			else {
+			} else {
 				spic_dev.cur_ioport = io;
 				break;
 			}
@@ -3311,7 +6014,8 @@ static int sony_pic_add(struct acpi_devi
 	if (result)
 		goto err_disable_device;
 
-	result = sysfs_create_group(&sony_pf_device->dev.kobj, &spic_attribute_group);
+	result = sysfs_create_group(&sony_pf_device->dev.kobj,
+					&spic_attribute_group);
 	if (result)
 		goto err_remove_pf;
 
